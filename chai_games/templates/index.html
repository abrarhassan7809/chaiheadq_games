<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galactic Defender: Turbo Edition</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/remixicon/4.6.0/remixicon.min.css" rel="stylesheet">
    <style>
        @font-face {
            font-family: 'GameFont';
            src: url('https://assets-persist.lovart.ai/agent-static-assets/Alibaba-PuHuiTi-Bold.otf');
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #050510;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            font-family: 'GameFont', sans-serif;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            background: #000;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlays */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10;
            color: white;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            backdrop-filter: blur(5px);
        }

        .overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        h1 {
            font-size: 120px;
            margin: 0 0 20px 0;
            background: linear-gradient(to bottom, #fff, #00d2ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(0, 210, 255, 0.5);
            letter-spacing: 5px;
            text-transform: uppercase;
        }

        h2 {
            font-size: 60px;
            color: #ffde00;
            margin: 0 0 40px 0;
            text-shadow: 0 0 20px rgba(255, 222, 0, 0.5);
        }

        p {
            font-size: 24px;
            color: #aaa;
            line-height: 1.6;
            margin-bottom: 40px;
            text-align: center;
            max-width: 800px;
        }

        .btn {
            padding: 20px 60px;
            font-size: 32px;
            font-family: 'GameFont', sans-serif;
            color: white;
            background: linear-gradient(45deg, #0066ff, #00c3ff);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 0 20px rgba(0, 195, 255, 0.4);
            transition: transform 0.1s, box-shadow 0.1s;
            margin: 10px;
        }

        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 40px rgba(0, 195, 255, 0.6);
        }

        .btn:active {
            transform: scale(0.95);
        }

        .btn-secondary {
            background: linear-gradient(45deg, #444, #666);
            box-shadow: none;
        }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-bottom: 40px;
            text-align: left;
            background: rgba(255, 255, 255, 0.05);
            padding: 40px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-item {
            font-size: 28px;
            color: #fff;
        }

        .stat-value {
            color: #00d2ff;
            font-weight: bold;
            float: right;
            margin-left: 40px;
        }

        /* Pause Button */
        #pause-btn {
            position: absolute;
            top: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            background: rgba(0, 100, 255, 0.2);
            border: 2px solid rgba(0, 200, 255, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 5;
            color: white;
            font-size: 30px;
            transition: 0.2s;
        }

        #pause-btn:hover {
            background: rgba(0, 100, 255, 0.5);
            transform: scale(1.1);
        }

        /* Turbo Indicator */
        #turbo-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 40%, rgba(0, 200, 255, 0.1) 100%);
            border: 5px solid rgba(0, 255, 255, 0.3);
            box-sizing: border-box;
            pointer-events: none;
            display: none;
            z-index: 4;
            mix-blend-mode: screen;
        }

        .controls-info {
            font-size: 18px;
            color: #888;
            margin-top: 20px;
            display: flex;
            gap: 30px;
        }

        .key {
            display: inline-block;
            padding: 4px 10px;
            background: #333;
            border-radius: 4px;
            color: #fff;
            font-size: 14px;
            margin: 0 4px;
            border-bottom: 2px solid #111;
        }

        /* Animation Keyframes */
        @keyframes pulse {
            0% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .blinking {
            animation: pulse 1s infinite alternate;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas" width="1920" height="1080"></canvas>
        <div id="turbo-overlay"></div>
        <div id="pause-btn"><i class="ri-pause-fill"></i></div>

        <!-- Start Screen -->
        <div id="start-screen" class="overlay active">
            <h1>Galactic Defender</h1>
            <h2>Turbo Edition</h2>
            <div class="controls-info" style="margin-bottom: 40px; flex-direction: column; align-items: center; gap: 15px;">
                <div><span class="key">WASD</span> / <span class="key">ARROWS</span> to Move</div>
                <div><span class="key">F</span> / <span class="key">CTRL</span> to Shoot</div>
                <div>Hold <span class="key">SPACE</span> for TURBO MODE (2.5x Speed)</div>
                <div><span class="key">P</span> to Pause</div>
            </div>
            <button class="btn" onclick="game.start()">START GAME</button>
        </div>

        <!-- Pause Screen -->
        <div id="pause-screen" class="overlay">
            <h1>PAUSED</h1>
            <div class="controls-info" style="margin-bottom: 40px;">
                <div>Hold <span class="key">SPACE</span> Turbo</div>
                <div><span class="key">F</span> Shoot</div>
            </div>
            <button class="btn" onclick="game.togglePause()">RESUME</button>
            <button class="btn btn-secondary" onclick="game.restart()">RESTART</button>
        </div>

        <!-- Stage Clear Screen -->
        <div id="stage-clear-screen" class="overlay">
            <h1>STAGE CLEAR!</h1>
            <h2 id="clear-title">STAGE 1 COMPLETE</h2>
            <div class="stat-grid">
                <div class="stat-item">Enemies Destroyed <span class="stat-value" id="clear-enemies">0</span></div>
                <div class="stat-item">Score <span class="stat-value" id="clear-score">0</span></div>
                <div class="stat-item">Accuracy <span class="stat-value" id="clear-accuracy">0%</span></div>
                <div class="stat-item">Rating <span class="stat-value" id="clear-rating">⭐⭐⭐</span></div>
            </div>
            <button class="btn" onclick="game.nextStage()">NEXT STAGE</button>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="overlay">
            <h1 style="color: #ff3333; -webkit-text-fill-color: #ff3333;">GAME OVER</h1>
            <p>Your ship has been destroyed.</p>
            <div class="stat-grid">
                <div class="stat-item">Final Score <span class="stat-value" id="over-score">0</span></div>
                <div class="stat-item">Stage Reached <span class="stat-value" id="over-stage">1</span></div>
            </div>
            <button class="btn" onclick="game.restart()">RETRY</button>
            <button class="btn btn-secondary" onclick="game.mainMenu()">MAIN MENU</button>
        </div>

        <!-- Victory Screen -->
        <div id="victory-screen" class="overlay">
            <h1 style="color: gold; -webkit-text-fill-color: gold;">VICTORY!</h1>
            <p>The galaxy is safe thanks to you, Commander!</p>
            <div class="stat-grid">
                <div class="stat-item">Total Score <span class="stat-value" id="vic-score">0</span></div>
                <div class="stat-item">Rank <span class="stat-value" id="vic-rank">S</span></div>
            </div>
            <button class="btn" onclick="game.restart()">PLAY AGAIN</button>
        </div>
    </div>

<script>
/**
 * GALACTIC DEFENDER - Game Engine
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const WIDTH = 1920;
const HEIGHT = 1080;

function resizeGame() {
    const container = document.getElementById('game-container');
    const scaleX = window.innerWidth / WIDTH;
    const scaleY = window.innerHeight / HEIGHT;
    const scale = Math.min(scaleX, scaleY);
    container.style.transform = `scale(${scale})`;
}

// Input Handling
const keys = {
    ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
    w: false, s: false, a: false, d: false,
    f: false, Control: false,
    " ": false, // Space for Turbo
    p: false
};

window.addEventListener('keydown', (e) => {
    if(keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.key.toLowerCase())) {
        keys[e.key] = true;
        if (e.key.toLowerCase() === 'p') game.togglePause();
    }
});

window.addEventListener('keyup', (e) => {
    if(keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.key.toLowerCase())) {
        keys[e.key] = false;
    }
});

document.getElementById('pause-btn').addEventListener('click', () => game.togglePause());

// Utility Functions
const rand = (min, max) => Math.random() * (max - min) + min;
const checkRectCollide = (r1, r2) => {
    return r1.x < r2.x + r2.w &&
           r1.x + r1.w > r2.x &&
           r1.y < r2.y + r2.h &&
           r1.y + r1.h > r2.y;
};
const lerp = (a, b, t) => a + (b - a) * t;

// Game Object Classes

class Player {
    constructor() {
        this.w = 60;
        this.h = 70;
        this.x = WIDTH / 2 - this.w / 2;
        this.y = HEIGHT - 150;
        this.speed = 8;
        this.hp = 100;
        this.maxHp = 100;
        this.vx = 0;
        this.vy = 0;
        this.weaponLevel = 1;
        this.lastShot = 0;
        this.shootDelay = 8; // Frames between shots
        this.invulnerable = 0;
        this.shield = 0; // Number of hits
        this.scoreMultiplier = 1;
        this.multiplierTimer = 0;
        this.rapidFire = false;
        this.rapidFireTimer = 0;
    }

    update(dt) {
        // Movement
        let dx = 0;
        let dy = 0;
        if (keys.ArrowLeft || keys.a) dx = -1;
        if (keys.ArrowRight || keys.d) dx = 1;
        if (keys.ArrowUp || keys.w) dy = -1;
        if (keys.ArrowDown || keys.s) dy = 1;

        // Smooth physics
        this.vx = lerp(this.vx, dx * this.speed, 0.2 * dt);
        this.vy = lerp(this.vy, dy * this.speed, 0.2 * dt);

        this.x += this.vx * dt;
        this.y += this.vy * dt;

        // Boundaries
        if (this.x < 0) this.x = 0;
        if (this.x > WIDTH - this.w) this.x = WIDTH - this.w;
        if (this.y < 0) this.y = 0;
        if (this.y > HEIGHT - this.h) this.y = HEIGHT - this.h;

        // Shooting
        if ((keys.f || keys.Control) && game.frame - this.lastShot > (this.rapidFire ? this.shootDelay / 1.5 : this.shootDelay)) {
            this.shoot();
            this.lastShot = game.frame;
        }

        // Timers
        if (this.invulnerable > 0) this.invulnerable -= dt;
        if (this.multiplierTimer > 0) {
            this.multiplierTimer -= dt/60;
            if (this.multiplierTimer <= 0) this.scoreMultiplier = 1;
        }
        if (this.rapidFireTimer > 0) {
            this.rapidFireTimer -= dt/60;
            if (this.rapidFireTimer <= 0) this.rapidFire = false;
        }
    }

    shoot() {
        // Weapon Logic
        const speed = 20;
        const color = '#00ffff';

        // Base bullet
        if (this.weaponLevel === 1) {
            game.bullets.push(new Bullet(this.x + this.w/2 - 4, this.y, 0, -speed, color, 8, 20, true));
        }
        else if (this.weaponLevel === 2) {
            game.bullets.push(new Bullet(this.x, this.y + 10, 0, -speed, color, 8, 20, true));
            game.bullets.push(new Bullet(this.x + this.w, this.y + 10, 0, -speed, color, 8, 20, true));
        }
        else if (this.weaponLevel === 3) {
            game.bullets.push(new Bullet(this.x + this.w/2 - 4, this.y - 10, 0, -speed, color, 8, 20, true));
            game.bullets.push(new Bullet(this.x, this.y + 10, -2, -speed*0.9, color, 8, 20, true));
            game.bullets.push(new Bullet(this.x + this.w, this.y + 10, 2, -speed*0.9, color, 8, 20, true));
        }
        else if (this.weaponLevel === 4) {
            game.bullets.push(new Bullet(this.x + this.w/2 - 4, this.y - 10, 0, -speed, color, 10, 25, true));
            game.bullets.push(new Bullet(this.x + 10, this.y + 5, -3, -speed*0.9, color, 8, 20, true));
            game.bullets.push(new Bullet(this.x + this.w - 10, this.y + 5, 3, -speed*0.9, color, 8, 20, true));
            game.bullets.push(new Bullet(this.x, this.y + 15, -6, -speed*0.8, color, 8, 20, true));
            game.bullets.push(new Bullet(this.x + this.w, this.y + 15, 6, -speed*0.8, color, 8, 20, true));
        }
        else { // Level 5
            // Giant center beam
             game.bullets.push(new Bullet(this.x + this.w/2 - 10, this.y - 20, 0, -speed*1.2, '#fff', 20, 40, true));
             for(let i=1; i<=3; i++) {
                 game.bullets.push(new Bullet(this.x + this.w/2, this.y, -i*3, -speed, color, 6, 15, true));
                 game.bullets.push(new Bullet(this.x + this.w/2, this.y, i*3, -speed, color, 6, 15, true));
             }
        }

        // Muzzle flash effect
        game.particles.push(new Particle(this.x + this.w/2, this.y, 0, 0, '#fff', 20, 5));

        game.stats.shotsFired++;
    }

    draw() {
        ctx.save();
        ctx.translate(this.x + this.w/2, this.y + this.h/2);

        // Shield
        if (this.shield > 0) {
            ctx.strokeStyle = `rgba(255, 200, 0, ${0.5 + Math.sin(game.frame * 0.1) * 0.2})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, this.w, 0, Math.PI * 2);
            ctx.stroke();
            // Hexagon effect
            ctx.globalAlpha = 0.2;
            ctx.fillStyle = '#ffaa00';
            ctx.fill();
            ctx.globalAlpha = 1;
        }

        // Tilt effect
        const tilt = -this.vx * 3;
        ctx.rotate(tilt * Math.PI / 180);

        // Invulnerable blinking
        if (this.invulnerable > 0 && Math.floor(game.frame / 4) % 2 === 0) {
            ctx.globalAlpha = 0.5;
        }

        // Main Body
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#00aaff';

        // Wings
        ctx.fillStyle = '#8899aa';
        ctx.beginPath();
        ctx.moveTo(0, -35); // Nose
        ctx.lineTo(30, 35); // Right Wing Tip
        ctx.lineTo(10, 25);
        ctx.lineTo(10, 35);
        ctx.lineTo(-10, 35);
        ctx.lineTo(-10, 25);
        ctx.lineTo(-30, 35); // Left Wing Tip
        ctx.closePath();
        ctx.fill();

        // Detail
        ctx.fillStyle = '#ccc';
        ctx.fillRect(-8, -10, 16, 45);

        // Cockpit
        ctx.fillStyle = '#00ffff';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.moveTo(0, -15);
        ctx.lineTo(5, 5);
        ctx.lineTo(-5, 5);
        ctx.closePath();
        ctx.fill();

        // Engine Flames
        ctx.shadowColor = '#0066ff';
        const flameLen = 20 + Math.random() * 15;
        ctx.fillStyle = '#00aaff';
        ctx.beginPath();
        ctx.moveTo(-10, 35);
        ctx.lineTo(-15, 35 + flameLen);
        ctx.lineTo(-5, 35 + flameLen);
        ctx.closePath();
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(10, 35);
        ctx.lineTo(5, 35 + flameLen);
        ctx.lineTo(15, 35 + flameLen);
        ctx.closePath();
        ctx.fill();

        ctx.restore();
    }

    takeDamage(amount) {
        if (this.invulnerable > 0) return;

        if (this.shield > 0) {
            this.shield--;
            this.invulnerable = 60;
            game.addFloatingText("SHIELD BLOCK!", this.x, this.y, '#ffff00');
            return;
        }

        this.hp -= amount;
        this.invulnerable = 60; // 1 second invulnerability
        game.cameraShake = 10;

        // Particles
        for(let i=0; i<10; i++) {
            game.particles.push(new Particle(this.x + this.w/2, this.y + this.h/2, rand(-5,5), rand(-5,5), '#ffaa00', rand(5,10), 30));
        }

        if (this.hp <= 0) {
            this.hp = 0;
            game.gameOver();
        }
    }
}

class Bullet {
    constructor(x, y, vx, vy, color, w, h, isPlayer) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.color = color;
        this.w = w;
        this.h = h;
        this.isPlayer = isPlayer;
        this.active = true;
    }

    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;

        // Trail effect
        if (game.frame % 3 === 0) {
            game.particles.push(new Particle(this.x + this.w/2, this.y + this.h/2, 0, 0, this.color, this.w/2, 10));
        }

        if (this.y < -50 || this.y > HEIGHT + 50 || this.x < -50 || this.x > WIDTH + 50) {
            this.active = false;
        }
    }

    draw() {
        ctx.save();
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.fillStyle = this.color;
        // Capsule shape
        ctx.beginPath();
        ctx.arc(this.x + this.w/2, this.y, this.w/2, Math.PI, 0);
        ctx.arc(this.x + this.w/2, this.y + this.h, this.w/2, 0, Math.PI);
        ctx.fill();
        ctx.restore();
    }
}

class Enemy {
    constructor(type) {
        this.type = type;
        this.active = true;
        this.maxHp = 1;
        this.scoreVal = 100;

        if (type === 1) { // Red Scout (Stage 1)
            this.w = 40; this.h = 40;
            this.x = rand(50, WIDTH - 50);
            this.y = -50;
            this.vx = 0;
            this.vy = 4;
            this.color = '#ff3333';
            this.hp = 1;
        }
        else if (type === 2) { // Green Cruiser (Stage 2)
            this.w = 60; this.h = 50;
            this.x = rand(50, WIDTH - 50);
            this.y = -60;
            this.vx = Math.random() > 0.5 ? 2 : -2;
            this.vy = 3;
            this.color = '#33ff33';
            this.hp = 2;
            this.maxHp = 2;
            this.zigzagTimer = 0;
        }
        else if (type === 3) { // Purple Elite (Stage 3)
            this.w = 50; this.h = 60;
            this.x = rand(50, WIDTH - 50);
            this.y = -70;
            this.vx = 0;
            this.vy = 6;
            this.color = '#aa33ff';
            this.hp = 3;
            this.maxHp = 3;
        }

        // Mini enemy from Boss 2
        else if (type === 4) {
            this.w = 30; this.h = 30;
            this.x = 0; // Set by spawner
            this.y = 0;
            this.vx = rand(-3, 3);
            this.vy = 5;
            this.color = '#ffff00';
            this.hp = 1;
        }
    }

    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;

        // Logic per type
        if (this.type === 2) {
            this.zigzagTimer += dt;
            if (this.zigzagTimer > 60) {
                this.vx *= -1;
                this.zigzagTimer = 0;
            }
        }
        else if (this.type === 3) {
            // Dive towards player
            if (this.y < game.player.y && Math.abs(this.x - game.player.x) > 10) {
                if (this.x < game.player.x) this.vx += 0.1 * dt;
                else this.vx -= 0.1 * dt;
                // Clamp speed
                if(this.vx > 4) this.vx = 4;
                if(this.vx < -4) this.vx = -4;
            }
        }

        // Shooting
        if (Math.random() < 0.01 * dt && this.y > 0) {
            let bSpeed = 8;
            let bColor = '#ff6600';

            if (this.type === 3) { // Rapid fire check
                game.bullets.push(new Bullet(this.x + this.w/2, this.y + this.h, 0, bSpeed+2, '#ff00ff', 8, 15, false));
            } else {
                game.bullets.push(new Bullet(this.x + this.w/2, this.y + this.h, 0, bSpeed, bColor, 8, 15, false));
            }
        }

        if (this.y > HEIGHT) this.active = false;
        if (this.x < 0 || this.x > WIDTH) this.vx *= -1; // Bounce off walls for some
    }

    draw() {
        ctx.save();
        ctx.translate(this.x + this.w/2, this.y + this.h/2);
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.fillStyle = this.color;

        if (this.type === 1 || this.type === 3) {
            // Triangle shape
            ctx.beginPath();
            ctx.moveTo(0, this.h/2);
            ctx.lineTo(this.w/2, -this.h/2);
            ctx.lineTo(-this.w/2, -this.h/2);
            ctx.closePath();
            ctx.fill();
        } else {
            // Boxy shape
            ctx.fillRect(-this.w/2, -this.h/2, this.w, this.h);
            // Detail
            ctx.fillStyle = '#000';
            ctx.fillRect(-5, -5, 10, 20);
        }

        // Engine glow
        ctx.fillStyle = '#fff';
        ctx.globalAlpha = 0.6;
        ctx.beginPath();
        ctx.arc(0, -this.h/2, 5, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();
    }

    takeDamage(amount) {
        this.hp -= amount;
        if (this.hp <= 0) {
            this.destroy();
        } else {
            // Flash white
            ctx.save();
            ctx.globalCompositeOperation = 'source-atop';
            ctx.fillStyle = 'white';
            ctx.fillRect(this.x, this.y, this.w, this.h);
            ctx.restore();
        }
    }

    destroy() {
        this.active = false;
        game.addScore(this.scoreVal);
        game.createExplosion(this.x + this.w/2, this.y + this.h/2, this.type === 3 ? 20 : 10);

        // Drop Powerup (20% chance)
        if (Math.random() < 0.2) {
            game.powerups.push(new PowerUp(this.x, this.y));
        }

        game.stats.enemiesKilled++;
        game.stageEnemiesCount++;
    }
}

class Boss {
    constructor(stage) {
        this.stage = stage;
        this.active = true;
        this.y = -200;
        this.vx = 2;
        this.vy = 0;
        this.enterTime = 0;
        this.timer = 0;
        this.maxHp = 0;
        this.name = "";

        if (stage === 1) {
            this.name = "DESTROYER";
            this.hp = 300;
            this.w = 150; this.h = 100;
            this.color = '#ff0000';
        } else if (stage === 2) {
            this.name = "CARRIER";
            this.hp = 500;
            this.w = 180; this.h = 120;
            this.color = '#00ff00';
        } else if (stage === 3) {
            this.name = "DREADNOUGHT";
            this.hp = 800;
            this.w = 200; this.h = 140;
            this.color = '#aa00ff';
        } else {
            this.name = "MOTHERSHIP";
            this.hp = 1200;
            this.w = 250; this.h = 180;
            this.color = '#ffffff';
        }

        this.maxHp = this.hp;
        this.x = WIDTH/2 - this.w/2;
    }

    update(dt) {
        // Entrance
        if (this.y < 100) {
            this.y += 2 * dt;
            return;
        }

        // Movement
        this.timer += dt;
        this.x += this.vx * dt;
        if (this.x <= 50 || this.x >= WIDTH - this.w - 50) {
            this.vx *= -1;
        }

        // Attack Patterns
        if (this.stage === 1) {
            // Shoot 3 bullets every 2 seconds (120 frames)
            if (this.timer % 120 < dt) {
                this.shootFan(3, 10);
            }
        }
        else if (this.stage === 2) {
            // Spread shot + minions
            if (this.timer % 150 < dt) {
                this.shootFan(5, 8);
                // Spawn 2 minions
                let e1 = new Enemy(4); e1.x = this.x; e1.y = this.y + this.h;
                let e2 = new Enemy(4); e2.x = this.x + this.w; e2.y = this.y + this.h;
                game.enemies.push(e1, e2);
            }
        }
        else if (this.stage === 3) {
             if (this.timer % 90 < dt) {
                 this.shootFan(7, 12);
                 // Homing missile sim (just aimed at player current pos)
                 let angle = Math.atan2(game.player.y - (this.y+this.h), game.player.x - (this.x+this.w/2));
                 let vx = Math.cos(angle) * 10;
                 let vy = Math.sin(angle) * 10;
                 game.bullets.push(new Bullet(this.x + this.w/2, this.y + this.h, vx, vy, '#ff00ff', 15, 15, false));
             }
        }
        else { // Final Boss
            const hpPct = this.hp / this.maxHp;
            let fireRate = 90;
            if (hpPct < 0.5) fireRate = 45;

            if (this.timer % fireRate < dt) {
                if (hpPct > 0.75) {
                    this.shootFan(5, 12);
                } else if (hpPct > 0.5) {
                    this.shootFan(9, 15);
                } else if (hpPct > 0.25) {
                    this.shootFan(7, 12);
                    // Spawn minions
                    if (Math.random() < 0.5) {
                         let e = new Enemy(4); e.x = this.x + this.w/2; e.y = this.y + this.h;
                         game.enemies.push(e);
                    }
                } else {
                    // Chaos mode
                    this.shootFan(12, 18);
                    game.bullets.push(new Bullet(rand(this.x, this.x+this.w), this.y+this.h, 0, 15, '#fff', 20, 40, false));
                }
            }
        }
    }

    shootFan(count, speed) {
        for (let i = 0; i < count; i++) {
            let angle = (Math.PI / (count - 1)) * i; // Semi circle spread? Too wide.
            // Cone spread
            let spread = 1.5; // radians approx 90 deg
            let startAngle = Math.PI/2 - spread/2;
            let currentAngle = startAngle + (spread / (count-1)) * i;

            let vx = Math.cos(currentAngle) * speed;
            let vy = Math.sin(currentAngle) * speed;

            game.bullets.push(new Bullet(this.x + this.w/2, this.y + this.h - 10, vx, vy, '#ffaa00', 10, 20, false));
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.shadowBlur = 20;
        ctx.shadowColor = this.color;

        // Hull
        ctx.fillStyle = '#333';
        ctx.fillRect(0, 0, this.w, this.h);

        // Armor plates
        ctx.fillStyle = this.color;
        ctx.fillRect(10, 10, this.w-20, this.h-20);

        // Core/Weakpoint
        ctx.fillStyle = `rgba(255, 255, 255, ${0.5 + Math.sin(game.frame * 0.1) * 0.5})`;
        ctx.beginPath();
        ctx.arc(this.w/2, this.h/2 + 20, 20, 0, Math.PI*2);
        ctx.fill();

        // Details
        ctx.fillStyle = '#000';
        ctx.fillRect(20, this.h-10, 20, 20); // Guns
        ctx.fillRect(this.w-40, this.h-10, 20, 20);

        ctx.restore();
    }

    takeDamage(amount) {
        this.hp -= amount;

        // Flash effect
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.fillRect(this.x, this.y, this.w, this.h);
        ctx.restore();

        if (this.hp <= 0) {
            this.destroy();
        }
    }

    destroy() {
        this.active = false;
        game.addScore(5000 * this.stage);
        game.createExplosion(this.x + this.w/2, this.y + this.h/2, 100);
        game.cameraShake = 50;

        // Massive explosion chain
        for(let i=0; i<20; i++) {
            setTimeout(() => {
                game.createExplosion(this.x + rand(0, this.w), this.y + rand(0, this.h), 40);
            }, i * 100);
        }

        setTimeout(() => {
            if (this.stage === 4) game.victory();
            else game.stageClear();
        }, 2000);
    }
}

class PowerUp {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.w = 40;
        this.h = 40;
        this.vy = 3;
        this.active = true;

        // Types: 0:B, 1:R, 2:S, 3:+, 4:Star, 5:Bomb
        const randVal = Math.random();
        if (randVal < 0.3) this.type = 0; // 30% Weapon
        else if (randVal < 0.45) this.type = 3; // 15% Health
        else if (randVal < 0.6) this.type = 1; // 15% Rapid
        else if (randVal < 0.75) this.type = 2; // 15% Shield
        else if (randVal < 0.9) this.type = 4; // 15% Score
        else this.type = 5; // 10% Bomb

        this.icons = ['B', 'R', 'S', '+', '★', '!'];
        this.colors = ['#00ffff', '#ffaa00', '#ffff00', '#00ff00', '#ffd700', '#ff0000'];
        this.labels = ['WEAPON UP', 'RAPID FIRE', 'SHIELD', 'HEALTH', '2x SCORE', 'NUKE'];
    }

    update(dt) {
        this.y += this.vy * dt;
        if (this.y > HEIGHT) this.active = false;
    }

    draw() {
        ctx.save();
        ctx.translate(this.x + 20, this.y + 20);
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.colors[this.type];

        // Background circle
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.beginPath();
        ctx.arc(0,0, 20, 0, Math.PI*2);
        ctx.fill();

        ctx.strokeStyle = this.colors[this.type];
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(0,0, 20, 0, Math.PI*2);
        ctx.stroke();

        // Text
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.icons[this.type], 0, 2);

        ctx.restore();
    }

    collect() {
        this.active = false;
        game.addFloatingText(this.labels[this.type], this.x, this.y, this.colors[this.type]);

        switch(this.type) {
            case 0: // Weapon
                if(game.player.weaponLevel < 5) game.player.weaponLevel++;
                break;
            case 1: // Rapid
                game.player.rapidFire = true;
                game.player.rapidFireTimer = 10;
                break;
            case 2: // Shield
                game.player.shield = 3;
                break;
            case 3: // Health
                game.player.hp = Math.min(game.player.maxHp, game.player.hp + 25);
                break;
            case 4: // Score
                game.player.scoreMultiplier = 2;
                game.player.multiplierTimer = 15;
                break;
            case 5: // Bomb
                // Kill all enemies
                game.enemies.forEach(e => e.destroy());
                game.bullets = []; // Clear enemy bullets too
                // Damage boss
                if(game.boss) game.boss.takeDamage(100);
                // Flash screen
                ctx.fillStyle = 'white';
                ctx.fillRect(0,0,WIDTH,HEIGHT);
                break;
        }
    }
}

class Particle {
    constructor(x, y, vx, vy, color, size, life) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.color = color;
        this.size = size;
        this.life = life;
        this.maxLife = life;
        this.active = true;
    }
    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.life -= dt;
        if (this.life <= 0) this.active = false;
    }
    draw() {
        ctx.save();
        ctx.globalAlpha = this.life / this.maxLife;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
    }
}

// Game Control
const game = {
    state: 'START', // START, PLAYING, PAUSED, TRANSITION, GAMEOVER, VICTORY
    frame: 0,
    score: 0,
    stage: 1,
    cameraShake: 0,

    player: null,
    enemies: [],
    bullets: [],
    particles: [],
    powerups: [],
    floatingTexts: [],
    stars: [],
    boss: null,

    stageEnemiesCount: 0,
    stageEnemiesGoal: 15, // 15, 20, 25
    spawnTimer: 0,

    stats: {
        enemiesKilled: 0,
        shotsFired: 0,
        startTime: 0
    },

    init() {
        // Generate stars
        for(let i=0; i<200; i++) {
            this.stars.push({
                x: rand(0, WIDTH),
                y: rand(0, HEIGHT),
                size: rand(1, 3),
                speed: rand(0.5, 3),
                alpha: rand(0.2, 1)
            });
        }

        // HUD
        this.hudScore = document.getElementById('score-display');

        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    },

    start() {
        document.getElementById('start-screen').classList.remove('active');
        this.resetGame();
        this.state = 'PLAYING';
        this.stats.startTime = Date.now();
    },

    resetGame() {
        this.player = new Player();
        this.enemies = [];
        this.bullets = [];
        this.particles = [];
        this.powerups = [];
        this.score = 0;
        this.stage = 1;
        this.boss = null;
        this.stageEnemiesCount = 0;
        this.stageEnemiesGoal = 15;
        this.stats = { enemiesKilled: 0, shotsFired: 0, startTime: Date.now() };
    },

    restart() {
        document.querySelectorAll('.overlay').forEach(el => el.classList.remove('active'));
        this.start();
    },

    mainMenu() {
        document.querySelectorAll('.overlay').forEach(el => el.classList.remove('active'));
        document.getElementById('start-screen').classList.add('active');
        this.state = 'START';
    },

    togglePause() {
        if (this.state === 'PLAYING') {
            this.state = 'PAUSED';
            document.getElementById('pause-screen').classList.add('active');
        } else if (this.state === 'PAUSED') {
            this.state = 'PLAYING';
            document.getElementById('pause-screen').classList.remove('active');
        }
    },

    nextStage() {
        document.getElementById('stage-clear-screen').classList.remove('active');
        this.stage++;
        this.stageEnemiesCount = 0;
        this.enemies = [];
        this.bullets = [];
        this.boss = null;

        // Full heal
        this.player.hp = 100;

        // Set goals
        if (this.stage === 2) this.stageEnemiesGoal = 20;
        if (this.stage === 3) this.stageEnemiesGoal = 25;
        if (this.stage === 4) this.stageEnemiesGoal = 0; // Final boss immediately

        // Visual transition
        this.state = 'TRANSITION';
        let overlayAlpha = 1;

        const transition = setInterval(() => {
            overlayAlpha -= 0.05;
            if(overlayAlpha <= 0) {
                clearInterval(transition);
                this.state = 'PLAYING';
                if(this.stage === 4) this.spawnBoss();
            }
        }, 50);
    },

    stageClear() {
        this.state = 'TRANSITION';
        document.getElementById('clear-title').innerText = `STAGE ${this.stage} COMPLETE`;
        document.getElementById('clear-enemies').innerText = this.stats.enemiesKilled;
        document.getElementById('clear-score').innerText = this.score.toLocaleString();

        // Calc accuracy
        let acc = this.stats.shotsFired > 0 ? Math.round((this.stats.enemiesKilled / this.stats.shotsFired) * 100 * 3) : 0; // *3 for multi-hit enemies approx
        if (acc > 100) acc = 100;
        document.getElementById('clear-accuracy').innerText = acc + "%";

        document.getElementById('stage-clear-screen').classList.add('active');
    },

    victory() {
        this.state = 'VICTORY';
        document.getElementById('vic-score').innerText = this.score.toLocaleString();
        document.getElementById('vic-rank').innerText = this.score > 50000 ? 'S' : (this.score > 30000 ? 'A' : 'B');
        document.getElementById('victory-screen').classList.add('active');
    },

    gameOver() {
        this.state = 'GAMEOVER';
        document.getElementById('over-score').innerText = this.score.toLocaleString();
        document.getElementById('over-stage').innerText = this.stage;
        document.getElementById('game-over-screen').classList.add('active');
    },

    spawnBoss() {
        this.boss = new Boss(this.stage);
        this.addFloatingText("WARNING: BOSS APPROACHING", WIDTH/2, HEIGHT/2, 'red', 40);
    },

    addFloatingText(text, x, y, color, size=24) {
        this.floatingTexts.push({
            text, x, y, color, size, life: 60, vy: -1
        });
    },

    addScore(amount) {
        const final = amount * this.player.scoreMultiplier;
        this.score += final;
    },

    createExplosion(x, y, size) {
        for(let i=0; i<15; i++) {
            this.particles.push(new Particle(x, y, rand(-5,5), rand(-5,5), rand(0,1)>0.5?'#ffaa00':'#ff0000', rand(2, size/2), rand(20, 40)));
        }
    },

    loop() {
        requestAnimationFrame(this.loop);

        let dt = 1;
        // Turbo Logic
        if (keys[' '] && this.state === 'PLAYING') {
            dt = 2.5;
            document.getElementById('turbo-overlay').style.display = 'block';
        } else {
            document.getElementById('turbo-overlay').style.display = 'none';
        }

        if (this.state === 'PAUSED') return;

        this.frame += dt;

        // Clear Canvas
        ctx.fillStyle = '#050510';
        ctx.fillRect(0, 0, WIDTH, HEIGHT);

        // Draw Background
        this.drawStars(dt);

        if (this.cameraShake > 0) {
            ctx.save();
            const sx = rand(-this.cameraShake, this.cameraShake);
            const sy = rand(-this.cameraShake, this.cameraShake);
            ctx.translate(sx, sy);
            this.cameraShake *= 0.9;
            if(this.cameraShake < 0.5) this.cameraShake = 0;
        }

        if (this.state === 'PLAYING') {
            // Spawning Logic
            if (!this.boss && this.stage < 4) {
                if (this.stageEnemiesCount >= this.stageEnemiesGoal) {
                    this.spawnBoss();
                } else {
                    this.spawnTimer += dt;
                    let spawnRate = 60; // Frames
                    if (this.stage === 2) spawnRate = 50;
                    if (this.stage === 3) spawnRate = 40;

                    if (this.spawnTimer > spawnRate) {
                        // Spawn Enemy
                        this.enemies.push(new Enemy(this.stage));
                        this.spawnTimer = 0;
                    }
                }
            }

            // Updates
            this.player.update(dt);

            if (this.boss) {
                this.boss.update(dt);
                if (!this.boss.active) this.boss = null;
            }

            // Entity Updates
            this.bullets.forEach(b => b.update(dt));
            this.enemies.forEach(e => e.update(dt));
            this.powerups.forEach(p => p.update(dt));
            this.particles.forEach(p => p.update(dt));

            // Clean up
            this.bullets = this.bullets.filter(b => b.active);
            this.enemies = this.enemies.filter(e => e.active);
            this.powerups = this.powerups.filter(p => p.active);
            this.particles = this.particles.filter(p => p.active);

            // Collisions
            this.checkCollisions();
        }

        // Draw Game Objects
        if (this.player) this.player.draw();

        this.enemies.forEach(e => e.draw());
        if (this.boss) this.boss.draw();
        this.powerups.forEach(p => p.draw());
        this.bullets.forEach(b => b.draw());
        this.particles.forEach(p => p.draw());

        // Floating Text
        this.floatingTexts.forEach((ft, i) => {
            ft.y += ft.vy * (dt > 1 ? dt/2 : 1);
            ft.life -= (dt > 1 ? dt/2 : 1);
            ctx.globalAlpha = Math.max(0, ft.life / 60);
            ctx.fillStyle = ft.color;
            ctx.font = `bold ${ft.size}px GameFont`;
            ctx.shadowColor = ft.color;
            ctx.shadowBlur = 10;
            ctx.fillText(ft.text, ft.x - ctx.measureText(ft.text).width/2, ft.y);
            if(ft.life <= 0) this.floatingTexts.splice(i, 1);
        });
        ctx.globalAlpha = 1;

        if (this.cameraShake > 0) ctx.restore();

        // HUD Drawing
        this.drawHUD();
    },

    checkCollisions() {
        // Player Bullets hitting Enemies/Boss
        this.bullets.forEach(b => {
            if (!b.active || !b.isPlayer) return;

            // Vs Enemies
            this.enemies.forEach(e => {
                if (!e.active) return;
                if (checkRectCollide({x: b.x, y: b.y, w: b.w, h: b.h}, {x: e.x, y: e.y, w: e.w, h: e.h})) {
                    b.active = false;
                    e.takeDamage(1);
                    game.createExplosion(b.x, b.y, 5);
                }
            });

            // Vs Boss
            if (this.boss && this.boss.active) {
                if (checkRectCollide({x: b.x, y: b.y, w: b.w, h: b.h}, {x: this.boss.x, y: this.boss.y, w: this.boss.w, h: this.boss.h})) {
                    b.active = false;
                    this.boss.takeDamage(1);
                    game.createExplosion(b.x, b.y, 5);
                }
            }
        });

        // Enemy Bullets hitting Player
        this.bullets.forEach(b => {
            if (!b.active || b.isPlayer) return;
            // Hitbox slightly smaller for player
            if (checkRectCollide({x: b.x, y: b.y, w: b.w, h: b.h}, {x: this.player.x + 15, y: this.player.y + 15, w: this.player.w - 30, h: this.player.h - 30})) {
                b.active = false;
                this.player.takeDamage(10);
            }
        });

        // Enemies hitting Player
        this.enemies.forEach(e => {
            if (!e.active) return;
            if (checkRectCollide({x: e.x, y: e.y, w: e.w, h: e.h}, {x: this.player.x + 10, y: this.player.y + 10, w: this.player.w - 20, h: this.player.h - 20})) {
                e.destroy();
                this.player.takeDamage(20);
            }
        });

        // Player collecting Powerups
        this.powerups.forEach(p => {
            if (!p.active) return;
            if (checkRectCollide({x: p.x, y: p.y, w: 40, h: 40}, {x: this.player.x, y: this.player.y, w: this.player.w, h: this.player.h})) {
                p.collect();
            }
        });
    },

    drawStars(dt) {
        ctx.fillStyle = '#fff';
        this.stars.forEach(star => {
            star.y += star.speed * dt;
            if (star.y > HEIGHT) {
                star.y = 0;
                star.x = rand(0, WIDTH);
            }
            ctx.globalAlpha = star.alpha;
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.size, 0, Math.PI*2);
            ctx.fill();
        });
        ctx.globalAlpha = 1;
    },

    drawHUD() {
        if (!this.player) return;

        // Health Bar
        const hpPct = this.player.hp / 100;
        const hpColor = hpPct > 0.5 ? '#00ff00' : (hpPct > 0.25 ? '#ffff00' : '#ff0000');

        ctx.fillStyle = '#333';
        ctx.fillRect(30, 30, 300, 30);
        ctx.fillStyle = hpColor;
        ctx.fillRect(30, 30, 300 * hpPct, 30);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(30, 30, 300, 30);

        ctx.fillStyle = '#fff';
        ctx.font = 'bold 20px GameFont';
        ctx.textAlign = 'left';
        ctx.fillText(`HEALTH: ${Math.floor(this.player.hp)}/100`, 35, 52);

        // Weapon Info (Under Health)
        ctx.fillStyle = '#00ffff';
        ctx.font = '18px GameFont';
        ctx.fillText(`WEAPON LVL: ${this.player.weaponLevel}`, 30, 90);

        // Powerup Timers
        let timerY = 120;
        if (this.player.rapidFire) {
            ctx.fillStyle = '#ffaa00';
            ctx.fillText(`RAPID FIRE: ${Math.ceil(this.player.rapidFireTimer)}s`, 30, timerY);
            timerY += 30;
        }
        if (this.player.scoreMultiplier > 1) {
            ctx.fillStyle = '#ffd700';
            ctx.fillText(`2X SCORE: ${Math.ceil(this.player.multiplierTimer)}s`, 30, timerY);
        }

        // Score
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 40px GameFont';
        ctx.textAlign = 'center';
        ctx.shadowColor = '#00aaff';
        ctx.shadowBlur = 10;
        ctx.fillText(`SCORE: ${Math.floor(this.score).toLocaleString()}`, WIDTH/2, 60);
        ctx.shadowBlur = 0;

        // Stage Info (Top Right - leave space for Pause btn)
        ctx.textAlign = 'right';
        ctx.font = 'bold 30px GameFont';
        if (this.boss) {
            ctx.fillStyle = '#ff3333';
            ctx.fillText("BOSS BATTLE", WIDTH - 120, 60);

            // Boss Health Bar
            const bHp = Math.max(0, this.boss.hp / this.boss.maxHp);
            const barW = 800;
            const barX = WIDTH/2 - barW/2;
            const barY = 100;

            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(barX, barY, barW, 20);
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(barX, barY, barW * bHp, 20);
            ctx.strokeStyle = '#fff';
            ctx.strokeRect(barX, barY, barW, 20);

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 18px GameFont';
            ctx.textAlign = 'center';
            ctx.fillText(`${this.boss.name}: ${Math.floor(this.boss.hp)}/${this.boss.maxHp}`, WIDTH/2, barY + 16);

        } else {
            ctx.fillStyle = '#00d2ff';
            ctx.fillText(`STAGE ${this.stage}/3`, WIDTH - 120, 60);
            ctx.font = '20px GameFont';
            if (this.stage < 4) {
                ctx.fillText(`ENEMIES: ${this.stageEnemiesCount}/${this.stageEnemiesGoal}`, WIDTH - 120, 90);
            } else {
                ctx.fillText(`FINAL BATTLE`, WIDTH - 120, 90);
            }
        }
    }
};

// Start initialization
game.init();
resizeGame();
window.addEventListener('resize', resizeGame);

</script>
</body>
</html>