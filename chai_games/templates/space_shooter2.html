<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Galactic Defender: Alpha Version</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/remixicon/4.6.0/remixicon.min.css" rel="stylesheet">
    <style>
        @font-face {
            font-family: 'GameFont';
            src: url('https://assets-persist.lovart.ai/agent-static-assets/Alibaba-PuHuiTi-Bold.otf');
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: #050510;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            width: 100vw;
            height: 100vh;
            font-family: 'GameFont', sans-serif;
            user-select: none;
            touch-action: none; /* Prevent touch scrolling */
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            background: #000;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            object-fit: contain; /* Maintain aspect ratio */
            background: #000;
        }

        /* UI Overlays - Fixed positioning relative to viewport */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10;
            color: white;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            backdrop-filter: blur(5px);
            padding: 20px;
            box-sizing: border-box;
        }

        .overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        /* Responsive text sizing */
        h1 {
            font-size: clamp(40px, 8vw, 100px);
            margin: 0 0 20px 0;
            background: linear-gradient(to bottom, #fff, #00d2ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(0, 210, 255, 0.5);
            letter-spacing: 2px;
            text-transform: uppercase;
            text-align: center;
            line-height: 1.2;
        }

        h2 {
            font-size: clamp(30px, 4vw, 60px);
            color: #ffde00;
            margin: 0 0 40px 0;
            text-shadow: 0 0 20px rgba(255, 222, 0, 0.5);
            text-align: center;
        }

        p {
            font-size: clamp(16px, 3vw, 24px);
            color: #aaa;
            line-height: 1.6;
            margin-bottom: 40px;
            text-align: center;
            max-width: 800px;
            padding: 0 20px;
        }

        .btn {
            padding: clamp(10px, 2vw, 20px) clamp(30px, 6vw, 60px);
            font-size: clamp(20px, 4vw, 32px);
            font-family: 'GameFont', sans-serif;
            color: white;
            background: linear-gradient(45deg, #0066ff, #00c3ff);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 0 20px rgba(0, 195, 255, 0.4);
            transition: transform 0.1s, box-shadow 0.1s;
            margin: 10px;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 40px rgba(0, 195, 255, 0.6);
        }

        .btn:active {
            transform: scale(0.95);
        }

        .btn-secondary {
            background: linear-gradient(45deg, #444, #666);
            box-shadow: none;
        }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: clamp(10px, 2vw, 20px);
            margin-bottom: 40px;
            text-align: left;
            background: rgba(255, 255, 255, 0.05);
            padding: clamp(20px, 4vw, 40px);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            width: 90%;
            max-width: 600px;
        }

        .stat-item {
            font-size: clamp(18px, 3vw, 28px);
            color: #fff;
            white-space: nowrap;
        }

        .stat-value {
            color: #00d2ff;
            font-weight: bold;
            float: right;
            margin-left: 20px;
        }

        /* Pause Button - Fixed positioning */
        #pause-btn {
            position: fixed;
            top: max(10px, 2vh);
            right: max(10px, 2vw);
            width: clamp(40px, 8vw, 60px);
            height: clamp(40px, 8vw, 60px);
            background: rgba(0, 100, 255, 0.2);
            border: 2px solid rgba(0, 200, 255, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 5;
            color: white;
            font-size: clamp(20px, 4vw, 30px);
            transition: 0.2s;
            backdrop-filter: blur(5px);
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }

        #pause-btn:hover {
            background: rgba(0, 100, 255, 0.5);
            transform: scale(1.1);
        }

        #pause-btn:active {
            transform: scale(0.9);
        }

        /* Turbo Overlay */
        #turbo-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle, transparent 40%, rgba(0, 200, 255, 0.1) 100%);
            border: 5px solid rgba(0, 255, 255, 0.3);
            box-sizing: border-box;
            pointer-events: none;
            display: none;
            z-index: 4;
            mix-blend-mode: screen;
        }

        .controls-info {
            font-size: clamp(14px, 2.5vw, 18px);
            color: #888;
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            padding: 0 20px;
        }

        .key {
            display: inline-block;
            padding: 4px 10px;
            background: #333;
            border-radius: 4px;
            color: #fff;
            font-size: clamp(12px, 2vw, 14px);
            margin: 0 4px;
            border-bottom: 2px solid #111;
        }

        /* Mobile-specific adjustments - IMPROVED TOUCH CONTROLS LAYOUT */
        @media (max-width: 768px) {
            .stat-grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .stat-item {
                white-space: normal;
                text-align: center;
            }

            .stat-value {
                float: none;
                margin-left: 10px;
                display: inline-block;
            }

            .controls-info {
                flex-direction: column;
                align-items: center;
                gap: 10px;
            }

            /* Move game canvas to top */
            #game-container {
                align-items: flex-start;
            }

            canvas {
                object-position: top;
            }
        }

        /* Animation Keyframes */
        @keyframes pulse {
            0% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .blinking {
            animation: pulse 1s infinite alternate;
        }

        /* IMPROVED TOUCH CONTROLS - LEFT/RIGHT LAYOUT */
        #touch-controls {
            position: fixed;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: none;
            justify-content: space-between;
            align-items: flex-end;
            z-index: 100;
            pointer-events: none;
            padding: 0 15px;
            box-sizing: border-box;
        }

        @media (max-width: 768px) {
            #touch-controls {
                display: flex;
            }
        }

        /* Left side - Movement controls (D-pad style) */
        .touch-left-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            pointer-events: auto;
        }

        .touch-dpad-row {
            display: flex;
            gap: 5px;
            justify-content: center;
        }

        /* Right side - Action controls */
        .touch-right-panel {
            display: flex;
            flex-direction: column;
            gap: 8px;
            pointer-events: auto;
        }

        .touch-btn {
            width: 50px;
            height: 50px;
            background: linear-gradient(145deg, rgba(30, 40, 60, 0.95), rgba(10, 20, 40, 0.98));
            border: 3px solid;
            border-radius: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 32px;
            backdrop-filter: blur(8px);
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            box-shadow: 0 8px 15px rgba(0, 0, 0, 0.7), 0 0 20px currentColor;
            transition: all 0.1s ease;
            position: relative;
            text-shadow: 0 0 10px currentColor;
        }

        .touch-btn:active {
            transform: scale(0.85);
            filter: brightness(1.5);
            box-shadow: 0 0 30px currentColor;
        }

        /* Movement buttons - Gold/Yellow theme */
        #touch-left, #touch-right, #touch-up, #touch-down {
            border-color: #ffaa00;
            color: #ffaa00;
            box-shadow: 0 0 15px rgba(255, 170, 0, 0.5);
        }

        #touch-left:active, #touch-right:active, #touch-up:active, #touch-down:active {
            background: linear-gradient(145deg, #ffaa00, #ff8800);
            color: white;
            border-color: #ffff00;
        }

        /* Fire button - Red theme */
        #touch-fire {
            border-color: #ff3333;
            color: #ff3333;
            box-shadow: 0 0 15px rgba(255, 51, 51, 0.5);
            width: 50px;
            height: 50px;
            font-size: 36px;
        }

        #touch-fire:active {
            background: linear-gradient(145deg, #ff3333, #cc0000);
            color: white;
            border-color: #ff8888;
        }

        /* Laser button - Purple theme */
        #touch-laser {
            border-color: #ff44cc;
            color: #ff44cc;
            box-shadow: 0 0 15px rgba(255, 68, 204, 0.5);
        }

        #touch-laser:active {
            background: linear-gradient(145deg, #ff44cc, #aa00aa);
            color: white;
            border-color: #ffaaff;
        }

        /* Turbo button - Green theme */
        #touch-turbo {
            border-color: #33ff33;
            color: #33ff33;
            box-shadow: 0 0 15px rgba(51, 255, 51, 0.5);
        }

        #touch-turbo:active {
            background: linear-gradient(145deg, #33ff33, #00aa00);
            color: white;
            border-color: #ffffff;
        }

        /* Button labels */
        .touch-btn::after {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 0 5px black, 0 0 10px currentColor;
            white-space: nowrap;
            background: rgba(0, 0, 0, 0.6);
            padding: 2px 8px;
            border-radius: 10px;
            border: 1px solid currentColor;
            letter-spacing: 0.5px;
        }

        #touch-left::after { content: "LEFT"; }
        #touch-right::after { content: "RIGHT"; }
        #touch-up::after { content: "UP"; }
        #touch-down::after { content: "DOWN"; }
        #touch-fire::after { content: "FIRE"; }
        #touch-laser::after { content: "LASER"; }
        #touch-turbo::after { content: "TURBO"; }

        /* Center D-pad button (optional - can be used as extra) */
        #touch-up {
            margin-bottom: -5px;
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 400px) {
            .touch-btn {
                width: 50px;
                height: 50px;
                font-size: 28px;
            }

            #touch-fire {
                width: 50px;
                height: 50px;
                font-size: 32px;
            }

            .touch-btn::after {
                font-size: 9px;
                bottom: -18px;
                padding: 2px 5px;
            }
        }

        @media (max-width: 350px) {
            .touch-btn {
                width: 48px;
                height: 48px;
                font-size: 24px;
            }

            #touch-fire {
                width: 55px;
                height: 55px;
                font-size: 28px;
            }
        }

        /* Pause button styling for mobile */
        @media (max-width: 768px) {
            #pause-btn {
                width: 45px;
                height: 45px;
                font-size: 24px;
                background: rgba(0, 0, 0, 0.7);
                border-width: 3px;
                top: 10px;
                right: 10px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="turbo-overlay"></div>
        <div id="pause-btn"><i class="ri-pause-fill"></i></div>

        <!-- IMPROVED Touch controls for mobile - LEFT/RIGHT LAYOUT -->
        <div id="touch-controls">
            <!-- Left side - Movement controls (D-pad style) -->
            <div class="touch-left-panel">
                <div class="touch-dpad-row">
                    <div class="touch-btn" id="touch-up"><i class="ri-arrow-up-line"></i></div>
                </div>
                <div class="touch-dpad-row">
                    <div class="touch-btn" id="touch-left"><i class="ri-arrow-left-line"></i></div>
                    <div class="touch-btn" id="touch-down"><i class="ri-arrow-down-line"></i></div>
                    <div class="touch-btn" id="touch-right"><i class="ri-arrow-right-line"></i></div>
                </div>
            </div>

            <!-- Right side - Action controls -->
            <div class="touch-right-panel">
                <div class="touch-btn" id="touch-fire"><i class="ri-flashlight-line"></i></div>
                <div class="touch-btn" id="touch-laser"><i class="ri-flashlight-fill"></i></div>
                <div class="touch-btn" id="touch-turbo"><i class="ri-rocket-line"></i></div>
            </div>
        </div>

        <!-- Start Screen -->
        <div id="start-screen" class="overlay active">
            <h1>Galactic Defender</h1>
            <h2>Alpha Version</h2>
            <div class="controls-info" style="margin-bottom: 40px;">
                <div><span class="key">WASD</span> / <span class="key">ARROWS</span> to Move</div>
                <div><span class="key">F</span> / <span class="key">CTRL</span> to Shoot</div>
                <div>Hold <span class="key">F</span> + <span class="key">SPACE</span> or press <span class="key">L</span> for LASER</div>
                <div>Hold <span class="key">SPACE</span> for TURBO</div>
                <div><span class="key">P</span> to Pause</div>
            </div>
            <button class="btn" onclick="game.start()">START GAME</button>
        </div>

        <!-- Pause Screen -->
        <div id="pause-screen" class="overlay">
            <h1>PAUSED</h1>
            <div class="controls-info" style="margin-bottom: 40px;">
                <div>Hold <span class="key">SPACE</span> Turbo</div>
                <div><span class="key">F</span> Shoot</div>
            </div>
            <button class="btn" onclick="game.togglePause()">RESUME</button>
            <button class="btn btn-secondary" onclick="game.restart()">RESTART</button>
        </div>

        <!-- Stage Clear Screen -->
        <div id="stage-clear-screen" class="overlay">
            <h1>STAGE CLEAR!</h1>
            <h2 id="clear-title">STAGE 1 COMPLETE</h2>
            <div class="stat-grid">
                <div class="stat-item">Enemies Destroyed <span class="stat-value" id="clear-enemies">0</span></div>
                <div class="stat-item">Score <span class="stat-value" id="clear-score">0</span></div>
                <div class="stat-item">Accuracy <span class="stat-value" id="clear-accuracy">0%</span></div>
                <div class="stat-item">Rating <span class="stat-value" id="clear-rating">⭐⭐⭐</span></div>
            </div>
            <button class="btn" onclick="game.nextStage()">NEXT STAGE</button>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="overlay">
            <h1 style="color: #ff3333; -webkit-text-fill-color: #ff3333;">GAME OVER</h1>
            <p>Your ship has been destroyed.</p>
            <div class="stat-grid">
                <div class="stat-item">Final Score <span class="stat-value" id="over-score">0</span></div>
                <div class="stat-item">Stage Reached <span class="stat-value" id="over-stage">1</span></div>
            </div>
            <button class="btn" onclick="game.restart()">RETRY</button>
            <button class="btn btn-secondary" onclick="game.mainMenu()">MAIN MENU</button>
        </div>

        <!-- Victory Screen -->
        <div id="victory-screen" class="overlay">
            <h1 style="color: gold; -webkit-text-fill-color: gold;">VICTORY!</h1>
            <p>The galaxy is safe thanks to you, Commander!</p>
            <div class="stat-grid">
                <div class="stat-item">Total Score <span class="stat-value" id="vic-score">0</span></div>
                <div class="stat-item">Rank <span class="stat-value" id="vic-rank">S</span></div>
            </div>
            <button class="btn" onclick="game.restart()">PLAY AGAIN</button>
        </div>
    </div>

<script>
/**
 * GALACTIC DEFENDER - Game Engine with Responsive Design
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Game dimensions (fixed for game logic)
const GAME_WIDTH = 1920;
const GAME_HEIGHT = 1080;

// Set canvas dimensions
canvas.width = GAME_WIDTH;
canvas.height = GAME_HEIGHT;

// Responsive scaling
let scale = 1;
let offsetX = 0;
let offsetY = 0;

function resizeGame() {
    const container = document.getElementById('game-container');
    const windowWidth = window.innerWidth;
    const windowHeight = window.innerHeight;

    // Calculate scale to fit the game while maintaining aspect ratio
    const scaleX = windowWidth / GAME_WIDTH;
    const scaleY = windowHeight / GAME_HEIGHT;
    scale = Math.min(scaleX, scaleY);

    // Calculate offsets to center the canvas
    const canvasWidth = GAME_WIDTH * scale;
    const canvasHeight = GAME_HEIGHT * scale;

    offsetX = (windowWidth - canvasWidth) / 2;
    offsetY = (windowHeight - canvasHeight) / 2;

    // Apply transform to canvas
    canvas.style.width = `${canvasWidth}px`;
    canvas.style.height = `${canvasHeight}px`;
    canvas.style.marginLeft = `${offsetX}px`;
    canvas.style.marginTop = `${offsetY}px`;

    // Update container background
    container.style.backgroundColor = '#000';
}

// Convert screen coordinates to game coordinates
function screenToGame(x, y) {
    const gameX = (x - offsetX) / scale;
    const gameY = (y - offsetY) / scale;
    return { x: gameX, y: gameY };
}

// Input Handling
const keys = {
    ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
    w: false, s: false, a: false, d: false,
    f: false, Control: false,
    " ": false,
    p: false,
    l: false, L: false
};

// Touch controls for mobile
let touchControls = {
    left: false,
    right: false,
    up: false,
    down: false,
    fire: false,
    laser: false,
    turbo: false
};

// Keyboard events
window.addEventListener('keydown', (e) => {
    if (e.key === " ") {
        e.preventDefault(); // Prevent page scroll
    }
    // Debug for L key
    if (e.key.toLowerCase() === 'l') {
        console.log("L key pressed down!");
    }

    if(keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.key.toLowerCase())) {
        keys[e.key] = true;
        if (e.key.toLowerCase() === 'p') game.togglePause();
    }
});

window.addEventListener('keyup', (e) => {
    // Debug for L key
    if (e.key.toLowerCase() === 'l') {
        console.log("L key released!");
    }

    if(keys.hasOwnProperty(e.key) || keys.hasOwnProperty(e.key.toLowerCase())) {
        keys[e.key] = false;
    }
});

// Touch controls setup
document.addEventListener('DOMContentLoaded', () => {
    const touchLeft = document.getElementById('touch-left');
    const touchRight = document.getElementById('touch-right');
    const touchUp = document.getElementById('touch-up');
    const touchDown = document.getElementById('touch-down');
    const touchFire = document.getElementById('touch-fire');
    const touchLaser = document.getElementById('touch-laser');
    const touchTurbo = document.getElementById('touch-turbo');

    function setupTouchControl(element, controlName) {
        if (!element) return;

        element.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchControls[controlName] = true;
            // Add haptic feedback if available (optional)
            if (window.navigator && window.navigator.vibrate) {
                window.navigator.vibrate(10);
            }
        });

        element.addEventListener('touchend', (e) => {
            e.preventDefault();
            touchControls[controlName] = false;
        });

        element.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            touchControls[controlName] = false;
        });
    }

    setupTouchControl(touchLeft, 'left');
    setupTouchControl(touchRight, 'right');
    setupTouchControl(touchUp, 'up');
    setupTouchControl(touchDown, 'down');
    setupTouchControl(touchFire, 'fire');
    setupTouchControl(touchLaser, 'laser');
    setupTouchControl(touchTurbo, 'turbo');
});

document.getElementById('pause-btn').addEventListener('click', () => game.togglePause());
document.getElementById('pause-btn').addEventListener('touchstart', (e) => {
    e.preventDefault();
    game.togglePause();
});

// Utility Functions
const rand = (min, max) => Math.random() * (max - min) + min;
const checkRectCollide = (r1, r2) => {
    return r1.x < r2.x + r2.w &&
           r1.x + r1.w > r2.x &&
           r1.y < r2.y + r2.h &&
           r1.y + r1.h > r2.y;
};
const lerp = (a, b, t) => a + (b - a) * t;

// Game Object Classes
class Player {
    constructor() {
        this.w = 60;
        this.h = 70;
        this.x = GAME_WIDTH / 2 - this.w / 2;
        this.y = GAME_HEIGHT - 150;
        this.speed = 8;
        this.hp = 100;
        this.maxHp = 100;
        this.vx = 0;
        this.vy = 0;
        this.weaponLevel = 1;
        this.lastShot = 0;
        this.shootDelay = 8;
        this.invulnerable = 0;
        this.shield = 0;
        this.scoreMultiplier = 1;
        this.multiplierTimer = 0;
        this.rapidFire = false;
        this.rapidFireTimer = 0;

        // Laser properties
        this.laserAmmo = 0;
        this.laserActive = false;
        this.laserCooldown = 0;
        this.lastLaserPress = 0; // Track last laser press to prevent multiple fires
    }

    // Add this new method to the Player class
    fireLaser() {
        // Debug check
        console.log("Attempting to fire laser. Ammo:", this.laserAmmo, "Cooldown:", this.laserCooldown);

        // Check if we can fire laser
        if (this.laserAmmo <= 0) {
            game.addFloatingText("NO LASER AMMO!", this.x, this.y - 50, '#ff0000', 20);
            return false;
        }

        if (this.laserCooldown > 0) {
            game.addFloatingText("LASER COOLDOWN!", this.x, this.y - 50, '#ffff00', 20);
            return false;
        }

        // Consume ammo and set cooldown
        this.laserAmmo--;
        this.laserCooldown = 60; // 1 second cooldown at 60fps
        this.laserActive = true;

        // Create visual feedback
        game.addFloatingText(`LASER! ${this.laserAmmo} LEFT`, this.x, this.y - 70, '#ff00ff', 30);

        // Camera shake
        game.cameraShake = 15;

        // Create multiple laser beams
        for (let i = -3; i <= 3; i++) {
            setTimeout(() => {
                if (game.state === 'PLAYING') {
                    // Create laser bullet
                    game.bullets.push(new LaserBullet(
                        this.x + this.w/2 - 5 + (i * 8),
                        this.y - 30,
                        0, -25,
                        '#ff0000', 6, 80, true
                    ));
                }
            }, i * 20); // Stagger the beams for a cooler effect
        }

        // Damage all enemies on screen
        let enemiesHit = 0;
        game.enemies.forEach(enemy => {
            if (enemy.active) {
                const distToEnemy = Math.abs(enemy.x + enemy.w/2 - (this.x + this.w/2));
                if (distToEnemy < 250) {
                    enemy.takeDamage(5);
                    game.createExplosion(enemy.x + enemy.w/2, enemy.y + enemy.h/2, 15);
                    enemiesHit++;
                }
            }
        });

        // Damage boss if present
        if (game.boss && game.boss.active) {
            const distToBoss = Math.abs(game.boss.x + game.boss.w/2 - (this.x + this.w/2));
            if (distToBoss < 300) {
                game.boss.takeDamage(25);
                game.addFloatingText("BOSS HIT!", game.boss.x, game.boss.y, '#ff0000', 30);
            }
        }

        // Particle effects
        for(let i=0; i<30; i++) {
            game.particles.push(new Particle(
                this.x + this.w/2 + rand(-40,40),
                this.y - 20 + rand(-20,20),
                rand(-3,3), rand(-8,-2),
                '#ff00ff', rand(4,10), 30
            ));
        }

        // Turn off laser active after animation
        setTimeout(() => {
            this.laserActive = false;
        }, 300);

        return true;
    }

    update(dt) {
        let dx = 0;
        let dy = 0;

        // Keyboard controls
        if (keys.ArrowLeft || keys.a || touchControls.left) dx = -1;
        if (keys.ArrowRight || keys.d || touchControls.right) dx = 1;
        if (keys.ArrowUp || keys.w || touchControls.up) dy = -1;
        if (keys.ArrowDown || keys.s || touchControls.down) dy = 1;

        this.vx = lerp(this.vx, dx * this.speed, 0.2 * dt);
        this.vy = lerp(this.vy, dy * this.speed, 0.2 * dt);

        this.x += this.vx * dt;
        this.y += this.vy * dt;

        // Keep player in bounds
        if (this.x < 0) this.x = 0;
        if (this.x > GAME_WIDTH - this.w) this.x = GAME_WIDTH - this.w;
        if (this.y < 0) this.y = 0;
        if (this.y > GAME_HEIGHT - this.h) this.y = GAME_HEIGHT - this.h;

        // Update laser cooldown
        if (this.laserCooldown > 0) {
            this.laserCooldown -= dt;
        }

        // FIXED: Laser activation - check for L key press or touch laser button
        const laserPressed = keys.l || keys.L || touchControls.laser; // Add touchControls.laser

        if (laserPressed && game.frame % 30 === 0) {
            console.log("L key or laser button pressed, ammo:", this.laserAmmo, "cooldown:", this.laserCooldown);
        }

        // Only fire if L is pressed and we haven't fired recently
        if (laserPressed && this.laserAmmo > 0 && this.laserCooldown <= 0 && game.frame - this.lastLaserPress > 10) {
            console.log("FIRING LASER! Ammo:", this.laserAmmo);
            this.fireLaser();
            this.lastLaserPress = game.frame;
        } else if (laserPressed && this.laserAmmo <= 0) {
            // Show feedback when trying to fire with no ammo
            if (game.frame % 30 === 0) {
                game.addFloatingText("NO LASER AMMO!", this.x, this.y - 50, '#ff0000', 20);
            }
        } else if (laserPressed && this.laserCooldown > 0) {
            // Show feedback when on cooldown
            if (game.frame % 30 === 0) {
                game.addFloatingText(`COOLDOWN: ${Math.ceil(this.laserCooldown/6)/10}s`, this.x, this.y - 50, '#ffff00', 20);
            }
        }

        // Regular shooting
        if ((keys.f || keys.Control || touchControls.fire) && game.frame - this.lastShot > (this.rapidFire ? this.shootDelay / 1.5 : this.shootDelay)) {
            this.shoot();
            this.lastShot = game.frame;
        }

        // Update powerup timers
        if (this.invulnerable > 0) this.invulnerable -= dt;
        if (this.multiplierTimer > 0) {
            this.multiplierTimer -= dt/60;
            if (this.multiplierTimer <= 0) this.scoreMultiplier = 1;
        }
        if (this.rapidFireTimer > 0) {
            this.rapidFireTimer -= dt/60;
            if (this.rapidFireTimer <= 0) this.rapidFire = false;
        }
    }

    shoot() {
        const speed = 20;
        const color = '#00ffff';

        if (this.weaponLevel === 1) {
            game.bullets.push(new Bullet(this.x + this.w/2 - 4, this.y, 0, -speed, color, 8, 20, true));
        }
        else if (this.weaponLevel === 2) {
            game.bullets.push(new Bullet(this.x, this.y + 10, 0, -speed, color, 8, 20, true));
            game.bullets.push(new Bullet(this.x + this.w, this.y + 10, 0, -speed, color, 8, 20, true));
        }
        else if (this.weaponLevel === 3) {
            game.bullets.push(new Bullet(this.x + this.w/2 - 4, this.y - 10, 0, -speed, color, 8, 20, true));
            game.bullets.push(new Bullet(this.x, this.y + 10, -2, -speed*0.9, color, 8, 20, true));
            game.bullets.push(new Bullet(this.x + this.w, this.y + 10, 2, -speed*0.9, color, 8, 20, true));
        }
        else if (this.weaponLevel === 4) {
            game.bullets.push(new Bullet(this.x + this.w/2 - 4, this.y - 10, 0, -speed, color, 10, 25, true));
            game.bullets.push(new Bullet(this.x + 10, this.y + 5, -3, -speed*0.9, color, 8, 20, true));
            game.bullets.push(new Bullet(this.x + this.w - 10, this.y + 5, 3, -speed*0.9, color, 8, 20, true));
            game.bullets.push(new Bullet(this.x, this.y + 15, -6, -speed*0.8, color, 8, 20, true));
            game.bullets.push(new Bullet(this.x + this.w, this.y + 15, 6, -speed*0.8, color, 8, 20, true));
        }
        else {
            game.bullets.push(new Bullet(this.x + this.w/2 - 10, this.y - 20, 0, -speed*1.2, '#fff', 20, 40, true));
            for(let i=1; i<=3; i++) {
                game.bullets.push(new Bullet(this.x + this.w/2, this.y, -i*3, -speed, color, 6, 15, true));
                game.bullets.push(new Bullet(this.x + this.w/2, this.y, i*3, -speed, color, 6, 15, true));
            }
        }

        game.particles.push(new Particle(this.x + this.w/2, this.y, 0, 0, '#fff', 20, 5));
        game.stats.shotsFired++;
    }

    draw() {
        ctx.save();
        ctx.translate(this.x + this.w/2, this.y + this.h/2);

        // Draw laser ammo indicator - IMPROVED
        if (this.laserAmmo > 0) {
            // Background glow
            ctx.shadowBlur = 30;
            ctx.shadowColor = '#ff00ff';

            // Laser ammo count with pulsing effect
            const pulseScale = 1 + Math.sin(game.frame * 0.1) * 0.1;
            ctx.fillStyle = '#ff00ff';
            ctx.font = `bold ${Math.floor(32 * pulseScale)}px GameFont`;
            ctx.textAlign = 'center';
            ctx.fillText(`⚡${this.laserAmmo}`, 0, -90);

            // Draw cooldown indicator
            if (this.laserCooldown > 0) {
                const cooldownPercent = this.laserCooldown / 60;
                ctx.fillStyle = '#ffff00';
                ctx.font = 'bold 20px GameFont';
                ctx.fillText(`⏳${Math.ceil(this.laserCooldown/6)/10}s`, 0, -50);
            } else {
                // Ready to fire indicator
                ctx.fillStyle = '#00ff00';
                ctx.font = 'bold 16px GameFont';
                ctx.fillText('READY', 0, -50);
            }

            // Hint to press L
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 14px GameFont';
            ctx.fillText('PRESS L', 0, -110);
        }

        // Draw shield indicator
        if (this.shield > 0) {
            ctx.strokeStyle = `rgba(255, 200, 0, ${0.5 + Math.sin(game.frame * 0.1) * 0.2})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, this.w, 0, Math.PI * 2);
            ctx.stroke();
            ctx.globalAlpha = 0.2;
            ctx.fillStyle = '#ffaa00';
            ctx.fill();
            ctx.globalAlpha = 1;
        }

        const tilt = -this.vx * 3;
        ctx.rotate(tilt * Math.PI / 180);

        if (this.invulnerable > 0 && Math.floor(game.frame / 4) % 2 === 0) {
            ctx.globalAlpha = 0.5;
        }

        ctx.shadowBlur = 20;
        ctx.shadowColor = '#00aaff';

        // Draw ship body
        ctx.fillStyle = '#8899aa';
        ctx.beginPath();
        ctx.moveTo(0, -35);
        ctx.lineTo(30, 35);
        ctx.lineTo(10, 25);
        ctx.lineTo(10, 35);
        ctx.lineTo(-10, 35);
        ctx.lineTo(-10, 25);
        ctx.lineTo(-30, 35);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = '#ccc';
        ctx.fillRect(-8, -10, 16, 45);

        ctx.fillStyle = '#00ffff';
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.moveTo(0, -15);
        ctx.lineTo(5, 5);
        ctx.lineTo(-5, 5);
        ctx.closePath();
        ctx.fill();

        // Draw engine flame (pulsing when turbo active)
        ctx.shadowColor = '#0066ff';
        const turboActive = keys[' '] || touchControls.turbo;
        const flameLen = 20 + (turboActive ? 30 : 0) + Math.random() * 15;

        ctx.fillStyle = turboActive ? '#ff6600' : '#00aaff';
        ctx.beginPath();
        ctx.moveTo(-10, 35);
        ctx.lineTo(-15, 35 + flameLen);
        ctx.lineTo(-5, 35 + flameLen);
        ctx.closePath();
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(10, 35);
        ctx.lineTo(5, 35 + flameLen);
        ctx.lineTo(15, 35 + flameLen);
        ctx.closePath();
        ctx.fill();

        ctx.restore();
    }

    takeDamage(amount) {
        if (this.invulnerable > 0) return;

        if (this.shield > 0) {
            this.shield--;
            this.invulnerable = 60;
            game.addFloatingText("SHIELD BLOCK!", this.x, this.y, '#ffff00');
            return;
        }

        this.hp -= amount;
        this.invulnerable = 60;
        game.cameraShake = 10;

        for(let i=0; i<10; i++) {
            game.particles.push(new Particle(this.x + this.w/2, this.y + this.h/2, rand(-5,5), rand(-5,5), '#ffaa00', rand(5,10), 30));
        }

        if (this.hp <= 0) {
            this.hp = 0;
            game.gameOver();
        }
    }
}

class Bullet {
    constructor(x, y, vx, vy, color, w, h, isPlayer) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.color = color;
        this.w = w;
        this.h = h;
        this.isPlayer = isPlayer;
        this.active = true;
    }

    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;

        if (game.frame % 3 === 0) {
            game.particles.push(new Particle(this.x + this.w/2, this.y + this.h/2, 0, 0, this.color, this.w/2, 10));
        }

        if (this.y < -50 || this.y > GAME_HEIGHT + 50 || this.x < -50 || this.x > GAME_WIDTH + 50) {
            this.active = false;
        }
    }

    draw() {
        ctx.save();
        ctx.shadowBlur = 10;
        ctx.shadowColor = this.color;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x + this.w/2, this.y, this.w/2, Math.PI, 0);
        ctx.arc(this.x + this.w/2, this.y + this.h, this.w/2, 0, Math.PI);
        ctx.fill();
        ctx.restore();
    }
}

class LaserBullet {
    constructor(x, y, vx, vy, color, w, h, isPlayer) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.color = color;
        this.w = w;
        this.h = h;
        this.isPlayer = isPlayer;
        this.active = true;
        this.life = 30; // Frames the laser stays active
        this.maxLife = 30;
        this.laserLength = 100;
    }

    update(dt) {
        this.life -= dt;
        if (this.life <= 0) {
            this.active = false;
            return;
        }

        this.y += this.vy * dt;

        // Add particles along laser
        if (game.frame % 2 === 0) {
            for(let i=0; i<2; i++) {
                game.particles.push(new Particle(
                    this.x + rand(-5,5),
                    this.y - rand(0, this.laserLength),
                    rand(-1,1), rand(-2,0),
                    '#ffff00', rand(2,4), 5
                ));
            }
        }
    }

    draw() {
        ctx.save();

        const alpha = this.life / this.maxLife;

        // Main laser beam
        ctx.globalAlpha = alpha;
        ctx.shadowBlur = 30;
        ctx.shadowColor = '#ff0000';
        ctx.strokeStyle = '#ff0000';
        ctx.lineWidth = this.w;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x, this.y - this.laserLength);
        ctx.stroke();

        // Inner glow
        ctx.shadowBlur = 40;
        ctx.strokeStyle = '#ffff00';
        ctx.lineWidth = this.w/2;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x, this.y - this.laserLength);
        ctx.stroke();

        // Laser tip
        ctx.fillStyle = '#ffffff';
        ctx.shadowBlur = 30;
        ctx.beginPath();
        ctx.arc(this.x, this.y - this.laserLength, 8, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();
    }
}

class Enemy {
    constructor(type) {
        this.type = type;
        this.active = true;
        this.maxHp = 1;
        this.scoreVal = 100;

        if (type === 1) { // Red Scout (Stage 1)
            this.w = 40; this.h = 40;
            this.x = rand(50, GAME_WIDTH - 50);
            this.y = -50;
            this.vx = 0;
            this.vy = 4;
            this.color = '#ff3333';
            this.hp = 1;
        }
        else if (type === 2) { // Green Cruiser (Stage 2)
            this.w = 60; this.h = 50;
            this.x = rand(50, GAME_WIDTH - 50);
            this.y = -60;
            this.vx = Math.random() > 0.5 ? 2 : -2;
            this.vy = 3;
            this.color = '#33ff33';
            this.hp = 2;
            this.maxHp = 2;
            this.zigzagTimer = 0;
        }
        else if (type === 3) { // Purple Elite (Stage 3)
            this.w = 50; this.h = 60;
            this.x = rand(50, GAME_WIDTH - 50);
            this.y = -70;
            this.vx = 0;
            this.vy = 6;
            this.color = '#aa33ff';
            this.hp = 3;
            this.maxHp = 3;
        }
        else if (type === 4) { // Blue Assault (Stage 4)
            this.w = 45; this.h = 45;
            this.x = rand(50, GAME_WIDTH - 50);
            this.y = -50;
            this.vx = rand(-3, 3);
            this.vy = 5;
            this.color = '#3366ff';
            this.hp = 2;
            this.maxHp = 2;
        }
        else if (type === 5) { // Yellow Bomber (Stage 5)
            this.w = 55; this.h = 40;
            this.x = rand(50, GAME_WIDTH - 50);
            this.y = -60;
            this.vx = 0;
            this.vy = 3;
            this.color = '#ffff33';
            this.hp = 3;
            this.maxHp = 3;
            this.bombTimer = 0;
        }
        else if (type === 6) { // Cyan Hunter (Stage 6)
            this.w = 50; this.h = 50;
            this.x = rand(50, GAME_WIDTH - 50);
            this.y = -70;
            this.vx = 0;
            this.vy = 5;
            this.color = '#33ffff';
            this.hp = 4;
            this.maxHp = 4;
        }
        else if (type === 7) { // Orange Destroyer (Stage 7)
            this.w = 65; this.h = 55;
            this.x = rand(50, GAME_WIDTH - 50);
            this.y = -80;
            this.vx = rand(-2, 2);
            this.vy = 4;
            this.color = '#ff9933';
            this.hp = 5;
            this.maxHp = 5;
        }
        else if (type === 8) { // Pink Nightmare (Stage 8)
            this.w = 70; this.h = 60;
            this.x = rand(50, GAME_WIDTH - 50);
            this.y = -90;
            this.vx = rand(-4, 4);
            this.vy = 6;
            this.color = '#ff33cc';
            this.hp = 6;
            this.maxHp = 6;
        }
    }

    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;

        if (this.type === 2) {
            this.zigzagTimer += dt;
            if (this.zigzagTimer > 60) {
                this.vx *= -1;
                this.zigzagTimer = 0;
            }
        }
        else if (this.type === 3 || this.type === 6 || this.type === 8) {
            if (this.y < game.player.y && Math.abs(this.x - game.player.x) > 10) {
                if (this.x < game.player.x) this.vx += 0.1 * dt;
                else this.vx -= 0.1 * dt;
                if(this.vx > 4) this.vx = 4;
                if(this.vx < -4) this.vx = -4;
            }
        }
        else if (this.type === 5) {
            this.bombTimer += dt;
            if (this.bombTimer > 90 && this.y > 100) {
                for(let i=0; i<3; i++) {
                    game.bullets.push(new Bullet(this.x + this.w/2, this.y + this.h, rand(-2,2), 8, '#ff6600', 8, 15, false));
                }
                this.bombTimer = 0;
            }
        }

        if (Math.random() < 0.01 * dt && this.y > 0) {
            let bSpeed = 8;
            let bColor = '#ff6600';

            if (this.type === 3) bColor = '#ff00ff';
            else if (this.type === 6) bColor = '#00ffff';
            else if (this.type === 7) bColor = '#ff8800';
            else if (this.type === 8) bColor = '#ff44aa';

            game.bullets.push(new Bullet(this.x + this.w/2, this.y + this.h, 0, bSpeed, bColor, 8, 15, false));
        }

        if (this.y > GAME_HEIGHT) this.active = false;
        if (this.x < 0 || this.x > GAME_WIDTH) this.vx *= -1;
    }

    draw() {
        ctx.save();
        ctx.translate(this.x + this.w/2, this.y + this.h/2);

        ctx.shadowBlur = 20;
        ctx.shadowColor = this.color;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.ellipse(0, 0, this.w/2, this.h/2, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#000';
        for (let i = 0; i < 6; i++) {
            let angle = (Math.PI * 2 / 6) * i;
            let sx = Math.cos(angle) * (this.w/2);
            let sy = Math.sin(angle) * (this.h/2);
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(sx * 1.3, sy * 1.3);
            ctx.lineTo(sx * 0.8, sy * 0.8);
            ctx.fill();
        }

        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(-10, -5, 8, 0, Math.PI*2);
        ctx.arc(10, -5, 8, 0, Math.PI*2);
        ctx.fill();

        ctx.fillStyle = "#000";
        ctx.beginPath();
        ctx.arc(-10, -5, 4, 0, Math.PI*2);
        ctx.arc(10, -5, 4, 0, Math.PI*2);
        ctx.fill();

        ctx.strokeStyle = "#000";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(0, 10, 15, 0, Math.PI);
        ctx.stroke();

        ctx.restore();
    }

    takeDamage(amount) {
        this.hp -= amount;
        if (this.hp <= 0) {
            this.destroy();
        }
    }

    destroy() {
        this.active = false;
        game.addScore(this.scoreVal);
        game.createExplosion(this.x + this.w/2, this.y + this.h/2, 10);

        if (Math.random() < 0.2) {
            game.powerups.push(new PowerUp(this.x, this.y));
        }

        game.stats.enemiesKilled++;
        game.stageEnemiesKilled++;
    }
}

class Boss {
    constructor(stage) {
        this.stage = stage;
        this.active = true;
        this.y = -200;
        this.vx = 2;
        this.vy = 0;
        this.enterTime = 0;
        this.timer = 0;
        this.maxHp = 0;
        this.name = "";
        this.powerBoostTriggered = false;
        this.rapidFireMultiplier = 1;

        // Boss colors matching enemy colors by stage
        const colors = [
            '#ff3333', // Stage 1 - Red
            '#33ff33', // Stage 2 - Green
            '#aa33ff', // Stage 3 - Purple
            '#3366ff', // Stage 4 - Blue
            '#ffff33', // Stage 5 - Yellow
            '#33ffff', // Stage 6 - Cyan
            '#ff9933', // Stage 7 - Orange
            '#ff33cc'  // Stage 8 - Pink
        ];

        this.color = colors[stage-1] || '#ff0000';

        if (stage === 1) {
            this.name = "DESTROYER";
            this.hp = 200;
            this.w = 200; this.h = 150;
        }
        else if (stage === 2) {
            this.name = "CARRIER";
            this.hp = 500;
            this.w = 210; this.h = 160;
        }
        else if (stage === 3) {
            this.name = "DREADNOUGHT";
            this.hp = 700;
            this.w = 220; this.h = 180;
        }
        else if (stage === 4) {
            this.name = "BATTLESHIP";
            this.hp = 900;
            this.w = 220; this.h = 180;
        }
        else if (stage === 5) {
            this.name = "ANNIHILATOR";
            this.hp = 1100;
            this.w = 230; this.h = 190;
        }
        else if (stage === 6) {
            this.name = "HARBINGER";
            this.hp = 1300;
            this.w = 230; this.h = 190;
        }
        else if (stage === 7) {
            this.name = "WAR TITAN";
            this.hp = 1500;
            this.w = 240; this.h = 200;
        }
        else if (stage === 8) {
            this.name = "OMEGA GOD";
            this.hp = 2000;
            this.w = 300; this.h = 220;
        }

        this.maxHp = this.hp;
        this.x = GAME_WIDTH/2 - this.w/2;
    }

    update(dt) {
        let hpPercent = this.hp / this.maxHp;

        if (!this.powerBoostTriggered && hpPercent <= 0.5) {
            this.powerBoostTriggered = true;
            this.rapidFireMultiplier = 1.5 + (this.stage * 0.1);
            game.addFloatingText("BOSS ENRAGED!", this.x + this.w/2, this.y - 50, 'red', 40);
        }

        if (this.y < 170) {
            this.y += 2 * dt;
            return;
        }

        this.timer += dt;
        this.x += this.vx * dt;
        if (this.x <= 50 || this.x >= GAME_WIDTH - this.w - 50) {
            this.vx *= -1;
        }

        let fireRateMod = this.powerBoostTriggered ? this.rapidFireMultiplier : 1;

        // Stage-specific attack patterns
        if (this.stage === 1) {
            if (this.timer % (120 / fireRateMod) < dt) this.shootFan(3, 10);
        } else if (this.stage === 2) {
            if (this.timer % (110 / fireRateMod) < dt) this.shootFan(4, 11);
        } else if (this.stage === 3) {
            if (this.timer % (100 / fireRateMod) < dt) this.shootFan(5, 12);
        } else if (this.stage === 4) {
            if (this.timer % (90 / fireRateMod) < dt) this.shootFan(6, 13);
        } else if (this.stage === 5) {
            if (this.timer % (80 / fireRateMod) < dt) this.shootFan(7, 14);
        } else if (this.stage === 6) {
            if (this.timer % (70 / fireRateMod) < dt) this.shootFan(8, 15);
        } else if (this.stage === 7) {
            if (this.timer % (60 / fireRateMod) < dt) this.shootFan(9, 16);
        } else if (this.stage === 8) {
            if (hpPercent > 0.75) {
                if (this.timer % (50 / fireRateMod) < dt) this.shootFan(12, 18);
            } else if (hpPercent > 0.5) {
                if (this.timer % (40 / fireRateMod) < dt) this.shootFan(14, 19);
                if (this.timer % 120 < dt) this.spawnMinions();
            } else if (hpPercent > 0.25) {
                if (this.timer % (30 / fireRateMod) < dt) this.shootFan(16, 20);
                if (this.timer % 90 < dt) this.spiralAttack();
            } else {
                if (this.timer % (20 / fireRateMod) < dt) this.shootFan(18, 22);
                if (this.timer % 60 < dt) this.spiralAttack();
                game.cameraShake = 5;
            }
        }
    }

    shootFan(count, speed) {
        if (this.powerBoostTriggered) count = Math.floor(count * this.rapidFireMultiplier);

        const spread = 1.5;
        const startAngle = Math.PI/2 - spread/2;

        for (let i = 0; i < count; i++) {
            let currentAngle = startAngle + (spread / (count-1)) * i;
            let vx = Math.cos(currentAngle) * speed;
            let vy = Math.sin(currentAngle) * speed;
            game.bullets.push(new Bullet(this.x + this.w/2, this.y + this.h - 10, vx, vy, this.color, 10, 20, false));
        }
    }

    spawnMinions() {
        for(let i=0; i<3; i++) {
            let enemy = new Enemy(4);
            enemy.x = this.x + rand(-50, this.w + 50);
            enemy.y = this.y + 50;
            enemy.vy = 3;
            game.enemies.push(enemy);
        }
    }

    spiralAttack() {
        for(let i=0; i<8; i++) {
            let angle = (Math.PI * 2 / 8) * i + this.timer * 0.05;
            let vx = Math.cos(angle) * 8;
            let vy = Math.sin(angle) * 8;
            game.bullets.push(new Bullet(this.x + this.w/2, this.y + this.h/2, vx, vy, '#ff0000', 12, 12, false));
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x + this.w/2, this.y + this.h/2);

        ctx.shadowBlur = 50;
        ctx.shadowColor = this.color;

        ctx.fillStyle = "#1a0000";
        ctx.beginPath();
        ctx.ellipse(0, 0, this.w/2, this.h/2, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.shadowBlur = 0;
        ctx.fillStyle = "#550000";

        ctx.beginPath();
        ctx.moveTo(-this.w/3, -this.h/3);
        ctx.quadraticCurveTo(-this.w/2, -this.h, -this.w/6, -this.h/2);
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(this.w/3, -this.h/3);
        ctx.quadraticCurveTo(this.w/2, -this.h, this.w/6, -this.h/2);
        ctx.fill();

        ctx.fillStyle = "red";
        ctx.beginPath();
        ctx.moveTo(-40, -20);
        ctx.lineTo(-10, -10);
        ctx.lineTo(-40, 0);
        ctx.closePath();
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(40, -20);
        ctx.lineTo(10, -10);
        ctx.lineTo(40, 0);
        ctx.closePath();
        ctx.fill();

        ctx.fillStyle = "white";
        ctx.beginPath();
        ctx.arc(-25, -12, 4, 0, Math.PI*2);
        ctx.arc(25, -12, 4, 0, Math.PI*2);
        ctx.fill();

        ctx.strokeStyle = "#ff0000";
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.arc(0, 25, 40, 0, Math.PI);
        ctx.stroke();

        ctx.fillStyle = "white";
        for (let i = -3; i <= 3; i++) {
            ctx.beginPath();
            ctx.moveTo(i * 10, 25);
            ctx.lineTo(i * 10 - 5, 45);
            ctx.lineTo(i * 10 + 5, 45);
            ctx.fill();
        }

        ctx.restore();
    }

    takeDamage(amount) {
        if (this.stage === 8) {
            amount = amount * 0.1;
        }

        this.hp -= amount;

        for (let i = 0; i < 5; i++) {
            game.particles.push(
                new Particle(
                    this.x + rand(0, this.w),
                    this.y + rand(0, this.h),
                    rand(-3, 3),
                    rand(-3, 3),
                    this.color,
                    rand(3, 8),
                    20
                )
            );
        }

        if (this.hp <= 0) {
            this.destroy();
        }
    }

    destroy() {
        if (this.stage >= 2) {
            let laserReward = 2 + Math.floor(this.stage / 2);
            game.player.laserAmmo += laserReward;
            // Show a very visible notification
            game.addFloatingText(`LASER +${laserReward}!`, this.x + this.w/2, this.y - 150, '#ff00ff', 50);
            game.addFloatingText(`TOTAL: ${game.player.laserAmmo}`, this.x + this.w/2, this.y - 100, '#ffffff', 40);

            // Flash the screen purple
            ctx.fillStyle = 'rgba(255,0,255,0.3)';
            ctx.fillRect(0,0,GAME_WIDTH,GAME_HEIGHT);
        }

        this.active = false;
        game.addScore(5000 * this.stage);
        game.createExplosion(this.x + this.w/2, this.y + this.h/2, 100);
        game.cameraShake = 50;

        for(let i=0; i<20; i++) {
            setTimeout(() => {
                game.createExplosion(this.x + rand(0, this.w), this.y + rand(0, this.h), 40);
            }, i * 100);
        }

        setTimeout(() => {
            if (this.stage === 8) {
                game.victory();
            } else {
                game.stageClear();
            }
        }, 2000);
    }
}

class PowerUp {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.w = 40;
        this.h = 40;
        this.vy = 3;
        this.active = true;

        // Updated powerup distribution with laser (type 6)
        const randVal = Math.random();
        if (randVal < 0.25) this.type = 0;      // Weapon Up
        else if (randVal < 0.4) this.type = 3;  // Health
        else if (randVal < 0.55) this.type = 1; // Rapid Fire
        else if (randVal < 0.7) this.type = 2;  // Shield
        else if (randVal < 0.85) this.type = 4; // 2x Score
        else if (randVal < 0.95) this.type = 5; // Nuke
        else this.type = 6;                      // Laser (new)

        this.icons = ['B', 'R', 'S', '+', '★', '!', '⚡'];
        this.colors = ['#00ffff', '#ffaa00', '#ffff00', '#00ff00', '#ffd700', '#ff0000', '#ff00ff'];
        this.labels = ['WEAPON UP', 'RAPID FIRE', 'SHIELD', 'HEALTH', '2x SCORE', 'NUKE', 'LASER'];
    }

    update(dt) {
        this.y += this.vy * dt;
        if (this.y > GAME_HEIGHT) this.active = false;
    }

    draw() {
        ctx.save();
        ctx.translate(this.x + 20, this.y + 20);
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.colors[this.type];

        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.beginPath();
        ctx.arc(0,0, 20, 0, Math.PI*2);
        ctx.fill();

        ctx.strokeStyle = this.colors[this.type];
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(0,0, 20, 0, Math.PI*2);
        ctx.stroke();

        ctx.fillStyle = '#fff';
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.icons[this.type], 0, 2);

        ctx.restore();
    }

    collect() {
        this.active = false;
        game.addFloatingText(this.labels[this.type], this.x, this.y, this.colors[this.type]);

        switch(this.type) {
            case 0: // Weapon Up
                if(game.player.weaponLevel < 5) game.player.weaponLevel++;
                break;
            case 1: // Rapid Fire
                game.player.rapidFire = true;
                game.player.rapidFireTimer = 10;
                break;
            case 2: // Shield
                game.player.shield = 3;
                break;
            case 3: // Health
                game.player.hp = Math.min(game.player.maxHp, game.player.hp + 25);
                break;
            case 4: // 2x Score
                game.player.scoreMultiplier = 2;
                game.player.multiplierTimer = 15;
                break;
            case 5: // Nuke
                game.enemies.forEach(e => e.destroy());
                game.bullets = game.bullets.filter(b => b.isPlayer);
                if(game.boss) game.boss.takeDamage(100);
                // Flash effect
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.fillRect(0,0,GAME_WIDTH,GAME_HEIGHT);
                break;
            case 6: // Laser
                game.player.laserAmmo += 3; // Add 3 laser shots
                game.addFloatingText("LASER +3!", this.x, this.y - 30, '#ff00ff', 40);
                game.addFloatingText(`TOTAL: ${game.player.laserAmmo}`, this.x, this.y, '#ffffff', 30);
                // Flash effect
                ctx.fillStyle = 'rgba(255,0,255,0.3)';
                ctx.fillRect(0,0,GAME_WIDTH,GAME_HEIGHT);
                break;
        }
    }
}

class Particle {
    constructor(x, y, vx, vy, color, size, life) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.color = color;
        this.size = size;
        this.life = life;
        this.maxLife = life;
        this.active = true;
    }
    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.life -= dt;
        if (this.life <= 0) this.active = false;
    }
    draw() {
        ctx.save();
        ctx.globalAlpha = this.life / this.maxLife;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
    }
}

// Game Control
const game = {
    state: 'START',
    frame: 0,
    score: 0,
    stage: 1,
    cameraShake: 0,
    lastFrameTime: null,

    player: null,
    enemies: [],
    bullets: [],
    particles: [],
    powerups: [],
    floatingTexts: [],
    stars: [],
    boss: null,
    bossSpawned: false,

    stageEnemiesKilled: 0,
    stageEnemiesGoal: 20,
    spawnTimer: 0,

    stats: {
        enemiesKilled: 0,
        shotsFired: 0,
        startTime: 0
    },

    init() {
        for(let i=0; i<200; i++) {
            this.stars.push({
                x: rand(0, GAME_WIDTH),
                y: rand(0, GAME_HEIGHT),
                size: rand(1, 3),
                speed: rand(0.5, 3),
                alpha: rand(0.2, 1)
            });
        }

        this.loop = this.loop.bind(this);
        requestAnimationFrame(this.loop);
    },

    start() {
        document.getElementById('start-screen').classList.remove('active');
        this.resetGame();
        this.state = 'PLAYING';
        this.stats.startTime = Date.now();
    },

    resetGame() {
        this.player = new Player();
        this.enemies = [];
        this.bullets = [];
        this.particles = [];
        this.powerups = [];
        this.score = 0;
        this.stage = 1;
        this.boss = null;
        this.bossSpawned = false;
        this.stageEnemiesKilled = 0;
        this.stageEnemiesGoal = 20;
        this.stats = { enemiesKilled: 0, shotsFired: 0, startTime: Date.now() };
    },

    restart() {
        document.querySelectorAll('.overlay').forEach(el => el.classList.remove('active'));
        this.start();
    },

    mainMenu() {
        document.querySelectorAll('.overlay').forEach(el => el.classList.remove('active'));
        document.getElementById('start-screen').classList.add('active');
        this.state = 'START';
    },

    togglePause() {
        if (this.state === 'PLAYING') {
            this.state = 'PAUSED';
            document.getElementById('pause-screen').classList.add('active');
        } else if (this.state === 'PAUSED') {
            this.state = 'PLAYING';
            document.getElementById('pause-screen').classList.remove('active');
        }
    },

    nextStage() {
        document.getElementById('stage-clear-screen').classList.remove('active');
        this.stage++;
        this.stageEnemiesKilled = 0;
        this.enemies = [];
        this.bullets = [];
        this.boss = null;
        this.bossSpawned = false;
        this.player.hp = 100;

        this.stageEnemiesGoal = 20 + (this.stage * 5);
        if (this.stageEnemiesGoal > 60) this.stageEnemiesGoal = 60;

        this.state = 'PLAYING';

        this.addFloatingText(`STAGE ${this.stage}`, GAME_WIDTH/2, GAME_HEIGHT/2, '#00ffff', 60);
    },

    stageClear() {
        this.state = 'TRANSITION';
        document.getElementById('clear-title').innerText = `STAGE ${this.stage} COMPLETE`;
        document.getElementById('clear-enemies').innerText = this.stats.enemiesKilled;
        document.getElementById('clear-score').innerText = this.score.toLocaleString();

        let acc = this.stats.shotsFired > 0 ? Math.round((this.stats.enemiesKilled / this.stats.shotsFired) * 100 * 3) : 0;
        if (acc > 100) acc = 100;
        document.getElementById('clear-accuracy').innerText = acc + "%";

        let stars = "⭐⭐⭐";
        if (acc > 80) stars = "⭐⭐⭐";
        else if (acc > 50) stars = "⭐⭐";
        else stars = "⭐";
        document.getElementById('clear-rating').innerText = stars;

        document.getElementById('stage-clear-screen').classList.add('active');
    },

    victory() {
        this.state = 'VICTORY';
        document.getElementById('vic-score').innerText = this.score.toLocaleString();
        let rank = this.score > 100000 ? 'S' : (this.score > 75000 ? 'A' : (this.score > 50000 ? 'B' : 'C'));
        document.getElementById('vic-rank').innerText = rank;
        document.getElementById('victory-screen').classList.add('active');
    },

    gameOver() {
        this.state = 'GAMEOVER';
        document.getElementById('over-score').innerText = this.score.toLocaleString();
        document.getElementById('over-stage').innerText = this.stage;
        document.getElementById('game-over-screen').classList.add('active');
    },

    spawnBoss() {
        this.boss = new Boss(this.stage);
        this.addFloatingText("WARNING: BOSS APPROACHING", GAME_WIDTH/2, GAME_HEIGHT/2, 'red', 40);
        this.enemies = [];
    },

    addFloatingText(text, x, y, color, size=24) {
        this.floatingTexts.push({
            text, x, y, color, size, life: 60, vy: -1
        });
    },

    addScore(amount) {
        const final = amount * this.player.scoreMultiplier;
        this.score += final;
    },

    createExplosion(x, y, size) {
        for(let i=0; i<15; i++) {
            this.particles.push(new Particle(x, y, rand(-5,5), rand(-5,5), rand(0,1)>0.5?'#ffaa00':'#ff0000', rand(2, size/2), rand(20, 40)));
        }
    },

    loop() {
        requestAnimationFrame(this.loop);

        // Calculate delta time properly
        const now = performance.now();
        const deltaTime = this.lastFrameTime ? (now - this.lastFrameTime) / 16.67 : 1;
        this.lastFrameTime = now;

        // Cap delta time to prevent huge jumps
        let dt = Math.min(deltaTime, 3);

        // Apply turbo if active
        if ((keys[' '] || touchControls.turbo) && this.state === 'PLAYING') {
            dt *= 2.5;
            document.getElementById('turbo-overlay').style.display = 'block';
        } else {
            document.getElementById('turbo-overlay').style.display = 'none';
        }

        if (this.state === 'PAUSED') return;

        this.frame += dt;

        ctx.fillStyle = '#050510';
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        this.drawStars(dt);

        if (this.cameraShake > 0) {
            ctx.save();
            const sx = rand(-this.cameraShake, this.cameraShake);
            const sy = rand(-this.cameraShake, this.cameraShake);
            ctx.translate(sx, sy);
            this.cameraShake *= 0.9;
            if(this.cameraShake < 0.5) this.cameraShake = 0;
        }

        if (this.state === 'PLAYING') {
            // Spawning Logic
            if (!this.boss && this.stage <= 8) {
                if (this.stageEnemiesKilled >= this.stageEnemiesGoal) {
                    if (!this.bossSpawned) {
                        this.spawnBoss();
                        this.bossSpawned = true;
                    }
                } else {
                    this.spawnTimer += dt;
                    let spawnRate = 50 - (this.stage * 2);
                    if (spawnRate < 20) spawnRate = 20;

                    if (this.spawnTimer > spawnRate) {
                        let enemyTypes = [];
                        if (this.stage === 1) enemyTypes = [1];
                        else if (this.stage === 2) enemyTypes = [1, 2];
                        else if (this.stage === 3) enemyTypes = [1, 2, 3];
                        else if (this.stage === 4) enemyTypes = [1, 2, 3, 4];
                        else if (this.stage === 5) enemyTypes = [2, 3, 4, 5];
                        else if (this.stage === 6) enemyTypes = [3, 4, 5, 6];
                        else if (this.stage === 7) enemyTypes = [4, 5, 6, 7];
                        else if (this.stage === 8) enemyTypes = [5, 6, 7, 8];

                        let type = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
                        this.enemies.push(new Enemy(type));
                        this.spawnTimer = 0;
                    }
                }
            }

            this.player.update(dt);

            if (this.boss) {
                this.boss.update(dt);
                if (!this.boss.active) this.boss = null;
            }

            this.bullets.forEach(b => b.update(dt));
            this.enemies.forEach(e => e.update(dt));
            this.powerups.forEach(p => p.update(dt));
            this.particles.forEach(p => p.update(dt));

            this.bullets = this.bullets.filter(b => b.active);
            this.enemies = this.enemies.filter(e => e.active);
            this.powerups = this.powerups.filter(p => p.active);
            this.particles = this.particles.filter(p => p.active);

            this.checkCollisions();
        }

        if (this.player) this.player.draw();
        this.enemies.forEach(e => e.draw());
        if (this.boss) this.boss.draw();
        this.powerups.forEach(p => p.draw());
        this.bullets.forEach(b => b.draw());
        this.particles.forEach(p => p.draw());

        this.floatingTexts.forEach((ft, i) => {
            ft.y += ft.vy * (dt > 1 ? dt/2 : 1);
            ft.life -= (dt > 1 ? dt/2 : 1);
            ctx.globalAlpha = Math.max(0, ft.life / 60);
            ctx.fillStyle = ft.color;
            ctx.font = `bold ${ft.size}px GameFont`;
            ctx.shadowColor = ft.color;
            ctx.shadowBlur = 10;
            ctx.fillText(ft.text, ft.x - ctx.measureText(ft.text).width/2, ft.y);
            if(ft.life <= 0) this.floatingTexts.splice(i, 1);
        });
        ctx.globalAlpha = 1;

        if (this.cameraShake > 0) ctx.restore();

        this.drawHUD();
    },

    checkCollisions() {
        this.bullets.forEach(b => {
            if (!b.active || !b.isPlayer) return;

            this.enemies.forEach(e => {
                if (!e.active) return;
                if (checkRectCollide({x: b.x, y: b.y, w: b.w, h: b.h}, {x: e.x, y: e.y, w: e.w, h: e.h})) {
                    b.active = false;
                    e.takeDamage(1);
                    game.createExplosion(b.x, b.y, 5);
                }
            });

            if (this.boss && this.boss.active) {
                if (checkRectCollide({x: b.x, y: b.y, w: b.w, h: b.h}, {x: this.boss.x, y: this.boss.y, w: this.boss.w, h: this.boss.h})) {
                    b.active = false;
                    this.boss.takeDamage(1);
                    this.addFloatingText("-1", b.x, b.y, "#ff0000", 20);
                    game.createExplosion(b.x, b.y, 5);
                }
            }
        });

        this.bullets.forEach(b => {
            if (!b.active || b.isPlayer) return;
            if (checkRectCollide({x: b.x, y: b.y, w: b.w, h: b.h}, {x: this.player.x + 15, y: this.player.y + 15, w: this.player.w - 30, h: this.player.h - 30})) {
                b.active = false;
                this.player.takeDamage(10);
            }
        });

        this.enemies.forEach(e => {
            if (!e.active) return;
            if (checkRectCollide({x: e.x, y: e.y, w: e.w, h: e.h}, {x: this.player.x + 10, y: this.player.y + 10, w: this.player.w - 20, h: this.player.h - 20})) {
                e.destroy();
                this.player.takeDamage(20);
            }
        });

        this.powerups.forEach(p => {
            if (!p.active) return;
            if (checkRectCollide({x: p.x, y: p.y, w: 40, h: 40}, {x: this.player.x, y: this.player.y, w: this.player.w, h: this.player.h})) {
                p.collect();
            }
        });
    },

    drawStars(dt) {
        ctx.fillStyle = '#fff';
        this.stars.forEach(star => {
            star.y += star.speed * dt;
            if (star.y > GAME_HEIGHT) {
                star.y = 0;
                star.x = rand(0, GAME_WIDTH);
            }
            ctx.globalAlpha = star.alpha;
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.size, 0, Math.PI*2);
            ctx.fill();
        });
        ctx.globalAlpha = 1;
    },

    drawHUD() {
        if (!this.player) return;

        const hpPct = this.player.hp / 100;
        const hpColor = hpPct > 0.5 ? '#00ff00' : (hpPct > 0.25 ? '#ffff00' : '#ff0000');

        ctx.fillStyle = '#333';
        ctx.fillRect(30, 30, 300, 30);
        ctx.fillStyle = hpColor;
        ctx.fillRect(30, 30, 300 * hpPct, 30);
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(30, 30, 300, 30);

        ctx.fillStyle = '#fff';
        ctx.font = 'bold 20px GameFont';
        ctx.textAlign = 'left';
        ctx.fillText(`HEALTH: ${Math.floor(this.player.hp)}/100`, 35, 52);

        ctx.fillStyle = '#00ffff';
        ctx.font = '18px GameFont';
        ctx.fillText(`WEAPON LVL: ${this.player.weaponLevel}`, 30, 90);

        let timerY = 120;
        if (this.player.rapidFire) {
            ctx.fillStyle = '#ffaa00';
            ctx.fillText(`RAPID FIRE: ${Math.ceil(this.player.rapidFireTimer)}s`, 30, timerY);
            timerY += 30;
        }
        if (this.player.scoreMultiplier > 1) {
            ctx.fillStyle = '#ffd700';
            ctx.fillText(`2X SCORE: ${Math.ceil(this.player.multiplierTimer)}s`, 30, timerY);
        }

        ctx.fillStyle = '#fff';
        ctx.font = 'bold 40px GameFont';
        ctx.textAlign = 'center';
        ctx.shadowColor = '#00aaff';
        ctx.shadowBlur = 10;
        ctx.fillText(`SCORE: ${Math.floor(this.score).toLocaleString()}`, GAME_WIDTH/2, 60);
        ctx.shadowBlur = 0;

        ctx.textAlign = 'right';
        ctx.font = 'bold 30px GameFont';
        if (this.boss) {
            ctx.fillStyle = this.boss.color;
            ctx.fillText("BOSS BATTLE", GAME_WIDTH - 120, 60);

            const bHp = Math.max(0, this.boss.hp / this.boss.maxHp);
            const barW = 800;
            const barX = GAME_WIDTH/2 - barW/2;
            const barY = 100;

            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(barX, barY, barW, 20);
            ctx.fillStyle = this.boss.color;
            ctx.fillRect(barX, barY, barW * bHp, 20);
            ctx.strokeStyle = '#fff';
            ctx.strokeRect(barX, barY, barW, 20);

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 18px GameFont';
            ctx.textAlign = 'center';
            ctx.fillText(`${this.boss.name}: ${Math.floor(this.boss.hp)}/${this.boss.maxHp}`, GAME_WIDTH/2, barY + 16);

        } else {
            ctx.fillStyle = '#00d2ff';
            ctx.fillText(`STAGE ${this.stage}/8`, GAME_WIDTH - 120, 60);
            ctx.font = '20px GameFont';
            if (this.stage < 8) {
                ctx.fillText(`ENEMIES: ${this.stageEnemiesKilled}/${this.stageEnemiesGoal}`, GAME_WIDTH - 120, 90);
            } else {
                ctx.fillText(`FINAL BATTLE`, GAME_WIDTH - 120, 90);
            }
        }
    }
};

// Prevent default touch actions
document.addEventListener('touchmove', (e) => {
    e.preventDefault();
}, { passive: false });

document.addEventListener('touchstart', (e) => {
    if (e.target.classList.contains('btn') || e.target.id.includes('touch')) {
        e.preventDefault();
    }
});

// Initialize
game.init();
window.addEventListener('resize', resizeGame);
resizeGame();

</script>
</body>
</html>